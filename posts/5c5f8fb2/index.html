<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="theme-color" content="#f8f5ec"><meta name="msapplication-navbutton-color" content="#f8f5ec"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec"><meta name="description" content="YYDiskCache 是一个`线程安全`的，用于存储由`SQLite`支持的键值对和`文件系统`（类似于 `NSURLCache` 的磁盘缓存）。采用LRU来移除数据；不同数据自动采用不同的存储机制：`sqlite` 或 `file`；支持`同步`与`异步`的方式调用等特性。"><link rel="alternate" href="/atom.xml" title="YotrolZ" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.11.0"><link rel="canonical" href="http://yotrolz.com/posts/5c5f8fb2/"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/yotrolz/yotrolz.github.io@gh/lib/fancybox/jquery.fancybox.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/yotrolz/yotrolz.github.io@gh/css/style.css?v=2.11.0"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-138610487-3"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-138610487-3")</script><script id="baidu_push">!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script src="//cdn.jsdelivr.net/npm/leancloud-storage@4.10.0/dist/av-min.js"></script><script id="leancloud">AV.init({appId:"mqfPQEKBtui9puAJUkYFY7Jn-MdYXbMMI",appKey:"A6R0T4bEvcBsTU8pB7NhJ6Wl"})</script><script>window.config={leancloud:{show_visits:!1,app_id:"mqfPQEKBtui9puAJUkYFY7Jn-MdYXbMMI",app_key:"A6R0T4bEvcBsTU8pB7NhJ6Wl"},toc:!0,fancybox:!0,pjax:"",latex:!1}</script><title>YYCache源码学习-磁盘缓存分析 - YotrolZ</title><meta name="generator" content="Hexo 5.4.1"></head><body><div id="mobile-navbar" class="mobile-navbar"><div class="mobile-header-logo"> <a href="/." class="logo">YotrolZ</a></div><div class="mobile-navbar-icon"><span></span><span></span><span></span></div></div><nav id="mobile-menu" class="mobile-menu slideout-menu"><ul class="mobile-menu-list"><a href="/"><li class="mobile-menu-item">Home</li></a><a href="/archives/"><li class="mobile-menu-item">Archives</li></a><a href="/tags/"><li class="mobile-menu-item">Tags</li></a><a href="/categories/"><li class="mobile-menu-item">Categories</li></a></ul></nav><div class="container" id="mobile-panel"><header id="header" class="header"><div class="logo-wrapper"> <a href="/." class="logo">YotrolZ</a></div><nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item"> <a class="menu-item-link" href="/">Home</a></li><li class="menu-item"> <a class="menu-item-link" href="/archives/">Archives</a></li><li class="menu-item"> <a class="menu-item-link" href="/tags/">Tags</a></li><li class="menu-item"> <a class="menu-item-link" href="/categories/">Categories</a></li></ul></nav></header><main id="main" class="main"><div class="content-wrapper"><div id="content" class="content"><article class="post"><header class="post-header"><h1 class="post-title">YYCache源码学习-磁盘缓存分析</h1><div class="post-meta"> <span class="post-time">2019-10-22</span> <span class="post-visits" style="display:none" data-url="/posts/5c5f8fb2/" data-title="YYCache源码学习-磁盘缓存分析">Visits 0</span></div></header><div class="post-toc" id="post-toc"><h2 class="post-toc-title">Contents</h2><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#YYDiskCache-%E7%AE%80%E4%BB%8B"><span class="toc-text">YYDiskCache 简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#YYDiskCache-%E6%BA%90%E7%A0%81%E6%80%BB%E8%A7%88"><span class="toc-text">YYDiskCache 源码总览</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#YYDiskCache-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">YYDiskCache 初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E7%BC%93%E5%AD%98%E4%B8%AD%E8%8E%B7%E5%8F%96YYDiskCache%E5%AF%B9%E8%B1%A1"><span class="toc-text">从缓存中获取YYDiskCache对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#YYDiskCacheInitGlobal"><span class="toc-text">_YYDiskCacheInitGlobal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#YYDiskCacheGetGlobal"><span class="toc-text">_YYDiskCacheGetGlobal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#YYDiskCacheSetGlobal"><span class="toc-text">_YYDiskCacheSetGlobal</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9C%9F%E6%AD%A3%E7%9A%84%E5%88%9B%E5%BB%BAYYDiskCache%E5%AF%B9%E8%B1%A1"><span class="toc-text">真正的创建YYDiskCache对象</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#YYDiskCache-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-text">YYDiskCache 线程安全</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#YYDiskCache-%E5%AD%98%E5%82%A8%E6%93%8D%E4%BD%9C"><span class="toc-text">YYDiskCache 存储操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6%EF%BC%9Ainline-data-file"><span class="toc-text">存储机制：inline_data &#x2F; file</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SQLite-DB-%E6%93%8D%E4%BD%9C"><span class="toc-text">SQLite DB 操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sqlite3-stmt"><span class="toc-text">sqlite3_stmt</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98-SQL-%E6%93%8D%E4%BD%9C"><span class="toc-text">缓存 SQL 操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sqlite3-WAL"><span class="toc-text">sqlite3 WAL</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#YYDiskCache-LRU"><span class="toc-text">YYDiskCache LRU</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#get-%E6%93%8D%E4%BD%9C%EF%BC%9A"><span class="toc-text">get 操作：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#trim-%E6%93%8D%E4%BD%9C"><span class="toc-text">trim 操作</span></a></li></ol></li></ol></div></div><div class="post-content"><p>在<a href="https://yotrolz.com/posts/ba9af90f/">上一篇文章</a>中，我们对<code>YYCache</code>的初始化操作了做了简单分析，具体代码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// YYCache.m</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithPath:(<span class="built_in">NSString</span> *)path &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ① 初始化磁盘缓存</span></span><br><span class="line">    YYDiskCache *diskCache = [[YYDiskCache alloc] initWithPath:path];</span><br><span class="line">    <span class="keyword">if</span> (!diskCache) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *name = [path lastPathComponent];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ② 初始化内存缓存</span></span><br><span class="line">    YYMemoryCache *memoryCache = [YYMemoryCache new];</span><br><span class="line">    memoryCache.name = name;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ③ 初始化本身并对内部的三个只读属性进行赋值</span></span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    _name = name;</span><br><span class="line">    _diskCache = diskCache;</span><br><span class="line">    _memoryCache = memoryCache;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>本篇文章我们介绍一下 <code>YYDiskCache</code> 磁盘缓存的实现</p></blockquote><h1 id="YYDiskCache-简介"><a href="#YYDiskCache-简介" class="headerlink" title="YYDiskCache 简介"></a>YYDiskCache 简介</h1><p>先来看一下官方介绍(可在源码中查阅):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">`YYDiskCache` 是一个`线程安全`的，用于存储由`SQLite`支持的键值对和`文件系统`（类似于 `NSURLCache` 的磁盘缓存）</span><br><span class="line"></span><br><span class="line">- 使用`LRU(least-recently-used)`来移除对象；</span><br><span class="line">- 可以通过 `cost`，`count` 和 `age` 来控制；</span><br><span class="line">- 可以配置为当`没有空闲磁盘空间`时`自动删除对象`；</span><br><span class="line">- 可以`自动决定`每个对象的`存储类型(sqlite/file)`，以获得更好的性能；</span><br><span class="line"></span><br><span class="line">在iOS系统上可以直接从官网下载最新的 `SQLite` 源码编译编译并忽略系统的`libsqlite3.dylib`可以获得`2x~4x`的速度。</span><br></pre></td></tr></table></figure><p>我们对上面的信息进行提炼一下关键信息：</p><ul><li>① 线程安全；</li><li>② 采用<code>LRU</code>移除对象；</li><li>③ 多维度的控制: <code>cost</code>，<code>count</code> 和 <code>age</code> ；</li><li>④ 不同数据自动采用不同的存储机制：<code>sqlite</code> 或 <code>file</code>；</li><li>⑤ 磁盘不足时可自动删除；</li><li>⑥ 支持<code>同步</code>与<code>异步</code>的方式调用(源码API层面)；</li></ul><blockquote><p>在提到<code>YYCache</code>的<code>LRU</code>时，网上大部分的文章都是再谈<code>双链表 + hash表</code>，该结构只是<code>YYCache</code>内存缓存(<code>YYMemoryCache</code>) 所采用的<code>LRU</code>方案，我们需要知道：YYCache 的磁盘缓存(<code>YYDiskCache</code>)也是支持<code>LRU</code>的;</p></blockquote><h1 id="YYDiskCache-源码总览"><a href="#YYDiskCache-源码总览" class="headerlink" title="YYDiskCache 源码总览"></a>YYDiskCache 源码总览</h1><h1 id="YYDiskCache-初始化"><a href="#YYDiskCache-初始化" class="headerlink" title="YYDiskCache 初始化"></a>YYDiskCache 初始化</h1><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYDiskCache</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Cache name</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="comment">// Cache path</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSString</span> *path;</span><br><span class="line"><span class="comment">// 磁盘缓存方式的一个阈值，默认是20480字节(20KB)</span></span><br><span class="line"><span class="comment">// 🔔❗️❗️❗️如果要存储的数据大小(以字节为单位)大于该阈值，则将其存储为文件，否则将其存储在sqlite中</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> inlineThreshold;</span><br><span class="line"></span><br><span class="line">······</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 (NS_DESIGNATED_INITIALIZER)</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)initWithPath:(<span class="built_in">NSString</span> *)path</span><br><span class="line">                      inlineThreshold:(<span class="built_in">NSUInteger</span>)threshold <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"></span><br><span class="line">······</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>初始化<code>YYCache</code>时调用了 <code>YYDiskCache</code> 的 <code>initWithPath</code> 方法</p><ul><li><p>这里主要是对 <code>inlineThreshold</code> 阈值进行了初始化(20KB)</p></li><li><p>至于为何是<code>20KB</code>，我们可以参看<a target="_blank" rel="noopener" href="https://blog.ibireme.com/2015/10/26/yycache/">YYCache 设计思路</a> 和 <a target="_blank" rel="noopener" href="https://www.sqlite.org/intern-v-extern-blob.html">SQLite官方说明</a></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithPath:(<span class="built_in">NSString</span> *)path &#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="keyword">self</span> initWithPath:path inlineThreshold:<span class="number">1024</span> * <span class="number">20</span>]; <span class="comment">// 20KB</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>真正的初始化方法<code>NS_DESIGNATED_INITIALIZER</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithPath:(<span class="built_in">NSString</span> *)path</span><br><span class="line">            inlineThreshold:(<span class="built_in">NSUInteger</span>)threshold &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ① 根据path利用_YYDiskCacheGetGlobal获取YYDiskCache对象</span></span><br><span class="line">    YYDiskCache *globalCache = _YYDiskCacheGetGlobal(path);</span><br><span class="line">    <span class="comment">// 存在的话直接返回，不需创建</span></span><br><span class="line">    <span class="keyword">if</span> (globalCache) <span class="keyword">return</span> globalCache;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ② 真正的初始化操作</span></span><br><span class="line">    ······ <span class="comment">// 下文分析</span></span><br><span class="line">    </span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(_appWillBeTerminated) name:<span class="built_in">UIApplicationWillTerminateNotification</span> object:<span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="从缓存中获取YYDiskCache对象"><a href="#从缓存中获取YYDiskCache对象" class="headerlink" title="从缓存中获取YYDiskCache对象"></a>从缓存中获取YYDiskCache对象</h2><p>在上文中我们得知，<code>YYDiskCache</code>在初始化的时候，首先会根据<code>path</code> 调用 <code>_YYDiskCacheGetGlobal</code>来进行查找，如果查到，就直接返回，如果没有找到就执行一系列的初始化操作，然后又调用 <code>_YYDiskCacheSetGlobal</code> 将创建好的<code>YYDiskCache</code> 对象存入，现在我们来分析一下 <code>_YYDiskCacheGetGlobal</code> 和 <code>_YYDiskCacheSetGlobal</code>；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// weak reference for all instances</span></span><br><span class="line"><span class="type">static</span> NSMapTable *_globalInstances;</span><br><span class="line"><span class="type">static</span> <span class="type">dispatch_semaphore_t</span> _globalInstancesLock;</span><br></pre></td></tr></table></figure><ul><li>定义了一个全局的 <code>NSMapTable</code> 类型的 <code>_globalInstances</code> 和 一个 <code>dispatch_semaphore_t</code> 类型的 <code>_globalInstancesLock</code>;</li><li><code>_globalInstances</code>：存放所有的 <code>YYDiskCache</code> 对象</li><li><code>dispatch_semaphore_t</code>：用来保证读写<code>YYDiskCache</code>对象的<code>线程安全</code></li></ul><h3 id="YYDiskCacheInitGlobal"><a href="#YYDiskCacheInitGlobal" class="headerlink" title="_YYDiskCacheInitGlobal"></a>_YYDiskCacheInitGlobal</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> _YYDiskCacheInitGlobal() &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        _globalInstancesLock = <span class="built_in">dispatch_semaphore_create</span>(<span class="number">1</span>);</span><br><span class="line">        _globalInstances = [[NSMapTable alloc] initWithKeyOptions:NSPointerFunctionsStrongMemory valueOptions:NSPointerFunctionsWeakMemory capacity:<span class="number">0</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用<code>dispatch_once</code>保证只初始化一次；</li><li>🔔❗️❗️❗️ <code>_globalInstances</code> 用来存放所有的 <code>YYDiskCache</code>对象， 使用 <code>NSMapTable</code> + <code>NSPointerFunctionsWeakMemory</code>， <code>弱引用</code> 内部的 <code>YYDiskCache</code>对象；</li><li>🔔❗️❗️❗️ <code>_globalInstancesLock</code> 用来保证读取<code>YYDiskCache</code>对象的线程安全；</li></ul><h3 id="YYDiskCacheGetGlobal"><a href="#YYDiskCacheGetGlobal" class="headerlink" title="_YYDiskCacheGetGlobal"></a>_YYDiskCacheGetGlobal</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> YYDiskCache *_YYDiskCacheGetGlobal(NSString *path) &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.length == <span class="number">0</span>) <span class="keyword">return</span> nil;</span><br><span class="line">    _YYDiskCacheInitGlobal();</span><br><span class="line">    <span class="built_in">dispatch_semaphore_wait</span>(_globalInstancesLock, DISPATCH_TIME_FOREVER);</span><br><span class="line">    id cache = [_globalInstances objectForKey:path];</span><br><span class="line">    <span class="built_in">dispatch_semaphore_signal</span>(_globalInstancesLock);</span><br><span class="line">    <span class="keyword">return</span> cache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="YYDiskCacheSetGlobal"><a href="#YYDiskCacheSetGlobal" class="headerlink" title="_YYDiskCacheSetGlobal"></a>_YYDiskCacheSetGlobal</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> _YYDiskCacheSetGlobal(YYDiskCache *cache) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cache.path.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    _YYDiskCacheInitGlobal();</span><br><span class="line">    <span class="built_in">dispatch_semaphore_wait</span>(_globalInstancesLock, DISPATCH_TIME_FOREVER);</span><br><span class="line">    [_globalInstances setObject:cache forKey:cache.path];</span><br><span class="line">    <span class="built_in">dispatch_semaphore_signal</span>(_globalInstancesLock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在调用<code>_YYDiskCacheGetGlobal</code> 或 <code>_YYDiskCacheSetGlobal</code> 时会调用<code>_YYDiskCacheInitGlobal</code> 进行初始化；</li><li>由于<code>_YYDiskCacheInitGlobal</code>内部使用<code>dispatch_once</code>，可保证只初始化了一次；</li></ul><blockquote><p>dispatch_semaphore_t 线程同步方案</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// creat：初始化，信号量初始值 1</span></span><br><span class="line">_globalInstancesLock = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// wait：对信号量数值减1，如果结果值`小于0`，则该函数处于等待状态， 直到超时或等待一个`唤醒信号`。</span></span><br><span class="line">dispatch_semaphore_wait(_globalInstancesLock, DISPATCH_TIME_FOREVER);</span><br><span class="line"><span class="comment">// signal：对信号量数值加1。如果`前一个值小于0`，这个函数在返回之前`唤醒`一个等待的线程(主要是针对上面的wait)。</span></span><br><span class="line">dispatch_semaphore_signal(_globalInstancesLock);</span><br></pre></td></tr></table></figure><h2 id="真正的创建YYDiskCache对象"><a href="#真正的创建YYDiskCache对象" class="headerlink" title="真正的创建YYDiskCache对象"></a>真正的创建YYDiskCache对象</h2><ul><li>根据<code>path</code> 和存储方式 <code>YYKVStorageType</code> 初始化 <code>YYKVStorage</code>；</li><li>初始化了一个 <code>dispatch_semaphore</code> 信号量；</li><li>初始化了一个 <code>dispatch_queue</code> 自定义的<code>并发队列</code>；</li><li>初始化一些额外的控制属性；</li><li>将上述初始化好的数据挂载到 <code>YYDiskCache</code> 对象上，并存入全局的 <code>_globalInstances</code> 中；</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithPath:(<span class="built_in">NSString</span> *)path</span><br><span class="line">            inlineThreshold:(<span class="built_in">NSUInteger</span>)threshold &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ① 根据path利用_YYDiskCacheGetGlobal获取YYDiskCache对象</span></span><br><span class="line">    YYDiskCache *globalCache = _YYDiskCacheGetGlobal(path);</span><br><span class="line">    <span class="comment">// 存在的话直接返回，不需创建</span></span><br><span class="line">    <span class="keyword">if</span> (globalCache) <span class="keyword">return</span> globalCache;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ② YYDiskCache 真正的初始化操作</span></span><br><span class="line">    YYKVStorageType type;</span><br><span class="line">    <span class="keyword">if</span> (threshold == <span class="number">0</span>) &#123;</span><br><span class="line">        type = YYKVStorageTypeFile;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (threshold == <span class="built_in">NSUIntegerMax</span>) &#123;</span><br><span class="line">        type = YYKVStorageTypeSQLite;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        type = YYKVStorageTypeMixed;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 真正实现数据存取的对象</span></span><br><span class="line">    YYKVStorage *kv = [[YYKVStorage alloc] initWithPath:path type:type];</span><br><span class="line">    <span class="keyword">if</span> (!kv) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    _kv = kv;</span><br><span class="line">    _path = path;</span><br><span class="line">    <span class="comment">// 使用GCD 信号量 创建了一把锁，保证线程安全</span></span><br><span class="line">    _lock = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 创建了一个自定义的并发队列</span></span><br><span class="line">    _queue = dispatch_queue_create(<span class="string">&quot;com.ibireme.cache.disk&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    _inlineThreshold = threshold;</span><br><span class="line">    _countLimit = <span class="built_in">NSUIntegerMax</span>;</span><br><span class="line">    _costLimit = <span class="built_in">NSUIntegerMax</span>;</span><br><span class="line">    _ageLimit = DBL_MAX;</span><br><span class="line">    _freeDiskSpaceLimit = <span class="number">0</span>;</span><br><span class="line">    _autoTrimInterval = <span class="number">60</span>;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> _trimRecursively];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ③ 存入：_YYDiskCacheSetGlobal</span></span><br><span class="line">    _YYDiskCacheSetGlobal(<span class="keyword">self</span>);</span><br><span class="line">    </span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(_appWillBeTerminated) name:<span class="built_in">UIApplicationWillTerminateNotification</span> object:<span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="YYDiskCache-线程安全"><a href="#YYDiskCache-线程安全" class="headerlink" title="YYDiskCache 线程安全"></a>YYDiskCache 线程安全</h1><p>在上文 <code>YYDiskCache</code> 初始化的时候，创建了一个 <code>dispatch_semaphore</code> 信号量；我们从API来分析 <code>YYDiskCache</code> 的线程安全；</p><blockquote><p>以 <code>- (void)removeObjectForKey:(NSString *)key</code> 为例:</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// self-&gt;_lock：初始化 YYDiskCache 时，创建的 dispatch_semaphore</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Lock()   dispatch_semaphore_wait(self-&gt;_lock, DISPATCH_TIME_FOREVER)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Unlock() dispatch_semaphore_signal(self-&gt;_lock)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步删除方式</span></span><br><span class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span>;</span><br><span class="line">    Lock();</span><br><span class="line">    [_kv removeItemForKey:key]; <span class="comment">// 线程安全</span></span><br><span class="line">    Unlock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 异步删除方式</span></span><br><span class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="built_in">NSString</span> *)key withBlock:(<span class="keyword">void</span>(^)(<span class="built_in">NSString</span> *key))block &#123;</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) _<span class="keyword">self</span> = <span class="keyword">self</span>;</span><br><span class="line">    <span class="comment">// _queue：初始化 YYDiskCache 时，创建的并发队列</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(_queue, ^&#123;</span><br><span class="line">        __<span class="keyword">strong</span> <span class="keyword">typeof</span>(_<span class="keyword">self</span>) <span class="keyword">self</span> = _<span class="keyword">self</span>;</span><br><span class="line">        [<span class="keyword">self</span> removeObjectForKey:key];</span><br><span class="line">        <span class="keyword">if</span> (block) block(key);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以看出真正在操作数据的其实是<code>[_kv removeItemForKey:key];</code></li><li><code>_kv</code> 就是在初始化 <code>YYDiskCache</code> 时，创建的 <code>YYKVStorage</code> 对象;</li></ul><blockquote><p>初始化 <code>YYDiskCache</code> 时，创建的 <code>dispatch_semaphore</code> 和 <code>dispatch_queue</code> 作用:</p></blockquote><ul><li><code>dispatch_semaphore</code> 用来保证<code>操作缓存数据</code>时的<code>线程安全</code>；</li><li>并发的<code>dispatch_queue</code> 用来实现<code>操作缓存数据</code>时的<code>同步</code>还是<code>异步</code>方式；</li></ul><p>我们只是以<code>删除操作</code>为例进行了说明：别的<code>操作</code>类似；</p><h1 id="YYDiskCache-存储操作"><a href="#YYDiskCache-存储操作" class="headerlink" title="YYDiskCache 存储操作"></a>YYDiskCache 存储操作</h1><blockquote><p>以 <code>- (void)setObject:(id&lt;NSCoding&gt;)object forKey:(NSString *)key;</code> 为例:</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// YYDiskCache.m</span></span><br><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)object forKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 如果 object 为 nil 就执行删除操作</span></span><br><span class="line">    <span class="keyword">if</span> (!object) &#123;</span><br><span class="line">        [<span class="keyword">self</span> removeObjectForKey:key];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// extendedData: 其实也就是 object 的一个附加数据；</span></span><br><span class="line">    <span class="comment">// 在保存 object 之前，如果给object设置了这个附加数据，YYDiskCache 也会一并存储；</span></span><br><span class="line">    <span class="comment">// 获取 object 绑定的 extendedData 数据</span></span><br><span class="line">    <span class="built_in">NSData</span> *extendedData = [YYDiskCache getExtendedDataFromObject:object];</span><br><span class="line">    <span class="comment">// object 对应的 NSData 数据</span></span><br><span class="line">    <span class="comment">// 可以自定义归档方式 或 使用默认的 NSKeyedArchiver</span></span><br><span class="line">    <span class="built_in">NSData</span> *value = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (_customArchiveBlock) &#123;</span><br><span class="line">        value = _customArchiveBlock(object);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">@try</span> &#123;</span><br><span class="line">            value = [<span class="built_in">NSKeyedArchiver</span> archivedDataWithRootObject:object];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">            <span class="comment">// nothing to do...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!value) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *filename = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (_kv.type != YYKVStorageTypeSQLite) &#123;</span><br><span class="line">        <span class="comment">// 🔔❗️❗️❗️</span></span><br><span class="line">        <span class="comment">// 如果没有明确标明存储方式为 SQLite 自动进行不同方式的存储机制 SQLite / File</span></span><br><span class="line">        <span class="comment">// 根据存储数据的字节数及阈值进行区分</span></span><br><span class="line">        <span class="keyword">if</span> (value.length &gt; _inlineThreshold) &#123;</span><br><span class="line">            <span class="comment">// 存储数据的大小超过了阈值 获取一个 filename 用于存储文件时使用</span></span><br><span class="line">            <span class="comment">// filename的生成规则，默认：MD5(key)；也可以通过 `customFileNameBlock(key)` 自定义</span></span><br><span class="line">            filename = [<span class="keyword">self</span> _filenameForKey:key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加解锁操作，保证数据访问时的线程安全</span></span><br><span class="line">    Lock();</span><br><span class="line">    <span class="comment">// 正真的存储操作</span></span><br><span class="line">    [_kv saveItemWithKey:key value:value filename:filename extendedData:extendedData];</span><br><span class="line">    Unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>有上述得知：<code>数据量超过阈值</code>后，会生成一个 <code>filename</code>，我们接着分析；</li></ul><h2 id="存储机制：inline-data-file"><a href="#存储机制：inline-data-file" class="headerlink" title="存储机制：inline_data / file"></a>存储机制：inline_data / file</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// YYKVStorage.m</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)saveItemWithKey:(<span class="built_in">NSString</span> *)key value:(<span class="built_in">NSData</span> *)value filename:(<span class="built_in">NSString</span> *)filename extendedData:(<span class="built_in">NSData</span> *)extendedData &#123;</span><br><span class="line">    <span class="keyword">if</span> (key.length == <span class="number">0</span> || value.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">if</span> (_type == YYKVStorageTypeFile &amp;&amp; filename.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 🔔❗️❗️❗️ 🔔❗️❗️❗️</span></span><br><span class="line">    <span class="keyword">if</span> (filename.length) &#123;</span><br><span class="line">    <span class="comment">// ① 若filename存在(数据量超过了阈值) --&gt; 采用`File`的方式</span></span><br><span class="line">        <span class="comment">// ①-① 写入 文件 的操作</span></span><br><span class="line">        <span class="keyword">if</span> (![<span class="keyword">self</span> _fileWriteWithName:filename data:value]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ①-② 写入 SQLite 的操作</span></span><br><span class="line">        <span class="keyword">if</span> (![<span class="keyword">self</span> _dbSaveWithKey:key value:value fileName:filename extendedData:extendedData]) &#123;</span><br><span class="line">            <span class="comment">// 操作失败后要将①-①中写入的文件删除</span></span><br><span class="line">            [<span class="keyword">self</span> _fileDeleteWithName:filename];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ② 若filename不存在(数据量小于阈值) --&gt; 采用`inline_data`的方式</span></span><br><span class="line">        <span class="keyword">if</span> (_type != YYKVStorageTypeSQLite) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *filename = [<span class="keyword">self</span> _dbGetFilenameWithKey:key];</span><br><span class="line">            <span class="keyword">if</span> (filename) &#123;</span><br><span class="line">                [<span class="keyword">self</span> _fileDeleteWithName:filename];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ②-① 写入 SQLite 的操作</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">self</span> _dbSaveWithKey:key value:value fileName:<span class="literal">nil</span> extendedData:extendedData];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>🔔❗️❗️❗️不管数据量超没超过阈值，都会在 <code>SQLite</code> 中写入一条数据的</p></blockquote><ul><li>超过阈值：<code>SQLite</code> + <code>File</code>；(不将<code>data</code>数据写入<code>SQLite</code>)</li><li>没超过阈值：<code>SQLite</code> + <code>inline_data</code>；</li><li>提高存储效率；</li></ul><p>我们看一下具体源码实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// YYKVStorage.m (私有方法)</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)_dbSaveWithKey:(<span class="built_in">NSString</span> *)key value:(<span class="built_in">NSData</span> *)value fileName:(<span class="built_in">NSString</span> *)fileName extendedData:(<span class="built_in">NSData</span> *)extendedData &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *sql = <span class="string">@&quot;insert or replace into manifest (key, filename, size, inline_data, modification_time, last_access_time, extended_data) values (?1, ?2, ?3, ?4, ?5, ?6, ?7);&quot;</span>;</span><br><span class="line"></span><br><span class="line">    🔔❗️❗️❗️🔔❗️❗️❗️🔔❗️❗️❗️ <span class="comment">// 下文分析</span></span><br><span class="line">    sqlite3_stmt *stmt = [<span class="keyword">self</span> _dbPrepareStmt:sql];</span><br><span class="line">    <span class="keyword">if</span> (!stmt) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> timestamp = (<span class="keyword">int</span>)time(<span class="literal">NULL</span>);</span><br><span class="line">    sqlite3_bind_text(stmt, <span class="number">1</span>, key.UTF8String, <span class="number">-1</span>, <span class="literal">NULL</span>);</span><br><span class="line">    sqlite3_bind_text(stmt, <span class="number">2</span>, fileName.UTF8String, <span class="number">-1</span>, <span class="literal">NULL</span>);</span><br><span class="line">    sqlite3_bind_int(stmt, <span class="number">3</span>, (<span class="keyword">int</span>)value.length);</span><br><span class="line">    🔔❗️❗️❗️🔔❗️❗️❗️🔔❗️❗️❗️</span><br><span class="line">    <span class="comment">// fileName 存在时，保存的数据其实是 NULL</span></span><br><span class="line">    <span class="keyword">if</span> (fileName.length == <span class="number">0</span>) &#123;</span><br><span class="line">        sqlite3_bind_blob(stmt, <span class="number">4</span>, value.bytes, (<span class="keyword">int</span>)value.length, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sqlite3_bind_blob(stmt, <span class="number">4</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sqlite3_bind_int(stmt, <span class="number">5</span>, timestamp);</span><br><span class="line">    sqlite3_bind_int(stmt, <span class="number">6</span>, timestamp);</span><br><span class="line">    sqlite3_bind_blob(stmt, <span class="number">7</span>, extendedData.bytes, (<span class="keyword">int</span>)extendedData.length, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> result = sqlite3_step(stmt);</span><br><span class="line">    <span class="keyword">if</span> (result != SQLITE_DONE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_errorLogsEnabled) <span class="built_in">NSLog</span>(<span class="string">@&quot;%s line:%d sqlite insert error (%d): %s&quot;</span>, __FUNCTION__, __LINE__, result, sqlite3_errmsg(_db));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SQLite-DB-操作"><a href="#SQLite-DB-操作" class="headerlink" title="SQLite DB 操作"></a>SQLite DB 操作</h2><p>看到这里，大家可能会想，<code>SQLite DB</code>操作无非就是写几行<code>SQL</code> 跑一下而已，有什么可说的。然而并非如此，<code>YYCache</code> 同样做了很多<code>提高性能</code>的事情!</p><h3 id="sqlite3-stmt"><a href="#sqlite3-stmt" class="headerlink" title="sqlite3_stmt"></a>sqlite3_stmt</h3><p>大家都知道<code>sqlite3</code> 有一个 执行的 <code>SQL</code> 语句的函数<code>sqlite3_exec</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SQLITE_API <span class="type">int</span> <span class="title">sqlite3_exec</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  sqlite3*,                                  <span class="comment">/* An open database */</span></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">const</span> <span class="type">char</span> *sql,                           <span class="comment">/* SQL to be evaluated */</span></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">int</span> (*callback)(<span class="type">void</span>*,<span class="type">int</span>,<span class="type">char</span>**,<span class="type">char</span>**),  <span class="comment">/* Callback function */</span></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">void</span> *,                                    <span class="comment">/* 1st argument to callback */</span></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">char</span> **errmsg                              <span class="comment">/* Error msg written here */</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>其实呢：<code>SQL</code>语句可以理解为一种<code>编程语言</code>的<code>源代码</code>，而想要执行这个<code>源代码</code>就必须要进行<code>编译/解析</code>，而<code>sqlite3_stmt</code>是一个<code>预编译语句对象</code>, 该对象的一个<code>实例</code>表示一条<code>SQL</code>语句，并且<code>已经被编译成二进制</code>形式，可以<code>直接运行</code>；</p><p><code>sqlite3_stmt</code> 的使用流程：</p><ul><li>① 使用<code>sqlite3_prepare_v2()</code>创建预处理语句对象；</li><li>② 使用<code>sqlite3_bind()</code>将值绑定到<code>SQL</code>上；</li><li>③ 通过调用<code>sqlite3_step()</code>一次或多次运行<code>SQL</code>;</li><li>④ 使用<code>sqlite3_reset()</code>重置准备好的语句，然后返回到步骤2。这样做0次或更多次。</li><li>⑤ 使用<code>sqlite3_finalize()</code>销毁对象。</li></ul><blockquote><p>YYCache 只有在初始化DB(<code>- (BOOL)_dbInitialize;</code>)时使用了<code>sqlite3_exec</code>执行<code>SQL</code>，而<code>重复性</code>的增删改查操作都是使用<code>sqlite3_stmt</code>来执行<code>SQL</code>;</p></blockquote><h3 id="缓存-SQL-操作"><a href="#缓存-SQL-操作" class="headerlink" title="缓存 SQL 操作"></a>缓存 <code>SQL</code> 操作</h3><p>接着回到我们的源码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接上文</span></span><br><span class="line">sqlite3_stmt *stmt = [<span class="keyword">self</span> _dbPrepareStmt:sql];</span><br></pre></td></tr></table></figure><blockquote><p>采用 <code>CFMutableDictionaryRef</code> 缓存 <code>sqlite3_stmt</code> 对象</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// YYKVStorage.m (私有方法)</span></span><br><span class="line">- (sqlite3_stmt *)_dbPrepareStmt:(<span class="built_in">NSString</span> *)sql &#123;</span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> _dbCheck] || sql.length == <span class="number">0</span> || !_dbStmtCache) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// ① 从缓存中查找 sqlite3_stmt 对象</span></span><br><span class="line">    sqlite3_stmt *stmt = (sqlite3_stmt *)<span class="built_in">CFDictionaryGetValue</span>(_dbStmtCache, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(sql));</span><br><span class="line">    <span class="keyword">if</span> (!stmt) &#123;</span><br><span class="line">        <span class="comment">// ②-① 缓存中没有 --&gt; 调用 sqlite3_prepare_v2 创建</span></span><br><span class="line">        <span class="keyword">int</span> result = sqlite3_prepare_v2(_db, sql.UTF8String, <span class="number">-1</span>, &amp;stmt, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (result != SQLITE_OK) &#123;</span><br><span class="line">            <span class="keyword">if</span> (_errorLogsEnabled) <span class="built_in">NSLog</span>(<span class="string">@&quot;%s line:%d sqlite stmt prepare error (%d): %s&quot;</span>, __FUNCTION__, __LINE__, result, sqlite3_errmsg(_db));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ②-② 将新创建的 sqlite3_stmt 对象 存入缓存</span></span><br><span class="line">        <span class="built_in">CFDictionarySetValue</span>(_dbStmtCache, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(sql), stmt);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ③ 缓存中存在 --&gt; 调用 sqlite3_reset 重置一下，供外界使用</span></span><br><span class="line">        sqlite3_reset(stmt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stmt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>[self _dbCheck]</code>其实是对DB数据库的一个校验与<code>重试</code>处理：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSUInteger</span> kMaxErrorRetryCount = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSTimeInterval</span> kMinRetryTimeInterval = <span class="number">2.0</span>;</span><br><span class="line">- (<span class="built_in">BOOL</span>)_dbCheck &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_db) &#123;</span><br><span class="line">        <span class="comment">// _dbOpenErrorCount: `sqlite3_open` 失败就会加一</span></span><br><span class="line">        <span class="keyword">if</span> (_dbOpenErrorCount &lt; kMaxErrorRetryCount &amp;&amp;</span><br><span class="line">            <span class="built_in">CACurrentMediaTime</span>() - _dbLastOpenErrorTime &gt; kMinRetryTimeInterval) &#123;</span><br><span class="line">            <span class="comment">// 重新打开 及 初始化</span></span><br><span class="line">            <span class="keyword">return</span> [<span class="keyword">self</span> _dbOpen] &amp;&amp; [<span class="keyword">self</span> _dbInitialize];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>[self _dbOpen]</code>内部会调用<code>sqlite3_open</code>打开数据库，打开成功后会创建了一个<code>_dbStmtCache</code>，用来缓存<code>sqlite3_stmt</code>对象；</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)_dbOpen &#123;</span><br><span class="line">    <span class="keyword">if</span> (_db) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> result = sqlite3_open(_dbPath.UTF8String, &amp;_db);</span><br><span class="line">    <span class="keyword">if</span> (result == SQLITE_OK) &#123;</span><br><span class="line">        <span class="built_in">CFDictionaryKeyCallBacks</span> keyCallbacks = kCFCopyStringDictionaryKeyCallBacks;</span><br><span class="line">        <span class="built_in">CFDictionaryValueCallBacks</span> valueCallbacks = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        _dbStmtCache = <span class="built_in">CFDictionaryCreateMutable</span>(<span class="built_in">CFAllocatorGetDefault</span>(), <span class="number">0</span>, &amp;keyCallbacks, &amp;valueCallbacks);</span><br><span class="line">        _dbLastOpenErrorTime = <span class="number">0</span>;</span><br><span class="line">        _dbOpenErrorCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _db = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (_dbStmtCache) <span class="built_in">CFRelease</span>(_dbStmtCache);</span><br><span class="line">        _dbStmtCache = <span class="literal">NULL</span>;</span><br><span class="line">        _dbLastOpenErrorTime = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">        _dbOpenErrorCount++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (_errorLogsEnabled) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;%s line:%d sqlite open failed (%d).&quot;</span>, __FUNCTION__, __LINE__, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sqlite3-WAL"><a href="#sqlite3-WAL" class="headerlink" title="sqlite3 WAL"></a>sqlite3 WAL</h3><ul><li><code>WAL</code>的全称是<code>Write Ahead Logging</code>，它是很多数据库中用于实现<code>原子事务</code>的一种机制，<code>SQLite</code>在<code>3.7.0</code>版本引入了该特性。</li><li>在引入<code>WAL</code>机制之前，<code>SQLite</code>使用<code>rollback journal</code>机制实现<code>原子事务</code>。</li></ul><blockquote><p><code>rollback journal</code> VS <code>WAL</code></p></blockquote><ul><li><code>rollback journal</code>机制：修改数据之前，先对要修改的数据进行<code>备份</code>，如果事务成功，就提交修改并删除备份；如果事务失败：就将备份数据拷贝回去，撤销修改；</li><li><code>WAL</code>机制：当修改数据时，并不直接写入数据库，而是写入到另外一个<code>WAL</code>文件中；如果事务成功：将会在随后的<code>某个时间节点</code>写回到数据库；如果事务失败：<code>WAL</code>文件中的记录会被忽略；<ul><li>同步<code>WAL</code>文件和数据库文件的行为称为<code>checkpoint</code>，它有<code>SQLite</code>自动执行，默认：<code>WAL</code>文件累计到<code>1000页</code>修改；</li><li>也可以通过<code>SQLITE_API int sqlite3_wal_checkpoint(sqlite3 *db, const char *zDb);</code>手动执行并重置<code>WAL</code>；</li></ul></li></ul><blockquote><p>可以在 <a target="_blank" rel="noopener" href="https://www.sqlite.org/pragma.html#pragma_wal_checkpoint">SQLite官方文档</a> 查阅相关使用介绍：</p></blockquote><ul><li><p><code>SQL</code>语句中使用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> journal_mode 模式；</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 比如：PRAGMA journal_mode <span class="operator">=</span> wal;</span><br><span class="line">PRAGMA journal_mode</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PRAGMA wal_checkpoint</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PRAGMA wal_autocheckpoint</span><br></pre></td></tr></table></figure></li><li><p>函数调用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将WAL中的预写日志转移到数据库文件中，并被重置WAL预写日志</span></span><br><span class="line"><span class="function">SQLITE_API <span class="type">int</span> <span class="title">sqlite3_wal_checkpoint</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    sqlite3 *db, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">char</span> *zDb</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置 autocheckpoint</span></span><br><span class="line"><span class="comment">// 每个新的[database connection] 默认开启 auto-checkpoint，默认值：1000</span></span><br><span class="line"><span class="function">SQLITE_API <span class="type">int</span> <span class="title">sqlite3_wal_autocheckpoint</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    sqlite3 *db, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> N</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册一个回调函数，在wal模式下，每次数据提交到数据库时都会调用这个回调函数</span></span><br><span class="line">SQLITE_API <span class="keyword">void</span> *sqlite3_wal_hook(</span><br><span class="line">    sqlite3*, </span><br><span class="line">    <span class="keyword">int</span>(*)(<span class="keyword">void</span> *,sqlite3*,<span class="keyword">const</span> <span class="keyword">char</span>*,<span class="keyword">int</span>),</span><br><span class="line">    <span class="keyword">void</span>*</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><blockquote><p><code>YYDiskCache</code> 中的 <code>SQLite WAL</code></p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)_dbInitialize &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *sql = <span class="string">@&quot;pragma journal_mode = wal; pragma synchronous = normal; create table if not exists manifest (key text, filename text, size integer, inline_data blob, modification_time integer, last_access_time integer, extended_data blob, primary key(key)); create index if not exists last_access_time_idx on manifest(last_access_time);&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> _dbExecute:sql];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)_dbCheckpoint &#123;</span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> _dbCheck]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// Cause a checkpoint to occur, merge `sqlite-wal` file to `sqlite` file.</span></span><br><span class="line">    sqlite3_wal_checkpoint(_db, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在<code>YYKVStorage.m</code>中的部分<code>remove</code>操作中使用到了<code>_dbCheckpoint</code></li></ul><h1 id="YYDiskCache-LRU"><a href="#YYDiskCache-LRU" class="headerlink" title="YYDiskCache LRU"></a>YYDiskCache LRU</h1><blockquote><p>以 <code>- (void)trimToCount:(NSUInteger)count;</code> 为例:</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// YYDiskCache.m</span></span><br><span class="line">- (<span class="keyword">void</span>)trimToCount:(<span class="built_in">NSUInteger</span>)count &#123;</span><br><span class="line">    Lock(); <span class="comment">// 加锁</span></span><br><span class="line">    [<span class="keyword">self</span> _trimToCount:count]; <span class="comment">// 移除操作</span></span><br><span class="line">    Unlock(); <span class="comment">// 解锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// YYDiskCache.m</span></span><br><span class="line">- (<span class="keyword">void</span>)_trimToCount:(<span class="built_in">NSUInteger</span>)countLimit &#123;</span><br><span class="line">    <span class="keyword">if</span> (countLimit &gt;= INT_MAX) <span class="keyword">return</span>;</span><br><span class="line">    [_kv removeItemsToFitCount:(<span class="keyword">int</span>)countLimit];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>真正的移除操作其实还是 <code>_kv</code>;</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// YYKVStorage.m</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)removeItemsToFitCount:(<span class="keyword">int</span>)maxCount &#123;</span><br><span class="line">    <span class="keyword">if</span> (maxCount == INT_MAX) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    <span class="keyword">if</span> (maxCount &lt;= <span class="number">0</span>) <span class="keyword">return</span> [<span class="keyword">self</span> removeAllItems];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> total = [<span class="keyword">self</span> _dbGetTotalItemCount];</span><br><span class="line">    <span class="keyword">if</span> (total &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">if</span> (total &lt;= maxCount) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSArray</span> *items = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">BOOL</span> suc = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// ① 定义每次从 SQLite DB 取出的数据量为：16个</span></span><br><span class="line">        <span class="keyword">int</span> perCount = <span class="number">16</span>;</span><br><span class="line">        <span class="comment">// ② 从 SQLite DB 取出相应数量的数据</span></span><br><span class="line">        items = [<span class="keyword">self</span> _dbGetItemSizeInfoOrderByTimeAscWithLimit:perCount];</span><br><span class="line">        <span class="comment">// ③ 对取出的数据进行遍历删除操作，直到符合删减的要求</span></span><br><span class="line">        <span class="keyword">for</span> (YYKVStorageItem *item <span class="keyword">in</span> items) &#123;</span><br><span class="line">            <span class="keyword">if</span> (total &gt; maxCount) &#123;</span><br><span class="line">                <span class="comment">// ③-① 如果是File方式，还需要将File一并删除</span></span><br><span class="line">                <span class="keyword">if</span> (item.filename) &#123;</span><br><span class="line">                    [<span class="keyword">self</span> _fileDeleteWithName:item.filename];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// ③-② 删除SQLite DB中的数据</span></span><br><span class="line">                suc = [<span class="keyword">self</span> _dbDeleteItemWithKey:item.key];</span><br><span class="line">                total--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!suc) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (total &gt; maxCount &amp;&amp; items.count &gt; <span class="number">0</span> &amp;&amp; suc);</span><br><span class="line">    <span class="keyword">if</span> (suc) [<span class="keyword">self</span> _dbCheckpoint];</span><br><span class="line">    <span class="keyword">return</span> suc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>① 定义每次从 SQLite DB 取出的数据量为：16个</li><li>② 从 SQLite DB 取出相应数量的数据</li><li>③ 对取出的数据进行遍历删除操作，直到符合删减的要求<ul><li>③-① 如果是File方式，还需要将File一并删除</li><li>③-② 删除SQLite DB中的数据</li></ul></li></ul><blockquote><p>由上可知：LRU 应该在 <code>② 从 SQLite DB 取出相应数量的数据；</code> 中有所体现；</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// YYKVStorage.m</span></span><br><span class="line">- (<span class="built_in">NSMutableArray</span> *)_dbGetItemSizeInfoOrderByTimeAscWithLimit:(<span class="keyword">int</span>)count &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *sql = <span class="string">@&quot;select key, filename, size from manifest order by last_access_time asc limit ?1;&quot;</span>;</span><br><span class="line">    sqlite3_stmt *stmt = [<span class="keyword">self</span> _dbPrepareStmt:sql];</span><br><span class="line">    <span class="keyword">if</span> (!stmt) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    sqlite3_bind_int(stmt, <span class="number">1</span>, count);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSMutableArray</span> *items = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> result = sqlite3_step(stmt);</span><br><span class="line">        <span class="keyword">if</span> (result == SQLITE_ROW) &#123;</span><br><span class="line">            <span class="keyword">char</span> *key = (<span class="keyword">char</span> *)sqlite3_column_text(stmt, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">char</span> *filename = (<span class="keyword">char</span> *)sqlite3_column_text(stmt, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> size = sqlite3_column_int(stmt, <span class="number">2</span>);</span><br><span class="line">            <span class="built_in">NSString</span> *keyStr = key ? [<span class="built_in">NSString</span> stringWithUTF8String:key] : <span class="literal">nil</span>;</span><br><span class="line">            <span class="keyword">if</span> (keyStr) &#123;</span><br><span class="line">                YYKVStorageItem *item = [YYKVStorageItem new];</span><br><span class="line">                item.key = key ? [<span class="built_in">NSString</span> stringWithUTF8String:key] : <span class="literal">nil</span>;</span><br><span class="line">                item.filename = filename ? [<span class="built_in">NSString</span> stringWithUTF8String:filename] : <span class="literal">nil</span>;</span><br><span class="line">                item.size = size;</span><br><span class="line">                [items addObject:item];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result == SQLITE_DONE) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (_errorLogsEnabled) <span class="built_in">NSLog</span>(<span class="string">@&quot;%s line:%d sqlite query error (%d): %s&quot;</span>, __FUNCTION__, __LINE__, result, sqlite3_errmsg(_db));</span><br><span class="line">            items = <span class="literal">nil</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> items;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行的<code>SQL</code>语句是：<br><code>select key, filename, size from manifest order by last_access_time asc limit ?1;</code></p><ul><li>按照<code>last_access_time</code>升序排列依次取出；</li><li>同样使用<code>sqlite3_stmt</code>执行<code>SQL</code>；</li></ul><blockquote><p>那么<code>last_access_time</code>升序和<code>LRU</code>有什么关系呢？</p></blockquote><p>那我们就不得不在提一个AP，以<code>- (nullable id&lt;NSCoding&gt;)objectForKey:(NSString *)key;</code>为例：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// YYDiskCache.m</span></span><br><span class="line">- (<span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)objectForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    Lock(); <span class="comment">// 加锁</span></span><br><span class="line">    YYKVStorageItem *item = [_kv getItemForKey:key]; <span class="comment">// get 操作(这里主要分析)</span></span><br><span class="line">    Unlock();<span class="comment">// 解锁</span></span><br><span class="line">    <span class="keyword">if</span> (!item.value) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">id</span> object = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (_customUnarchiveBlock) &#123;</span><br><span class="line">        object = _customUnarchiveBlock(item.value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">@try</span> &#123;</span><br><span class="line">            object = [<span class="built_in">NSKeyedUnarchiver</span> unarchiveObjectWithData:item.value];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">            <span class="comment">// nothing to do...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (object &amp;&amp; item.extendedData) &#123;</span><br><span class="line">        [YYDiskCache setExtendedData:item.extendedData toObject:object];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>真正的读取操作其实还是 <code>_kv</code>;</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// YYKVStorage.m</span></span><br><span class="line">- (YYKVStorageItem *)getItemForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">if</span> (key.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    YYKVStorageItem *item = [<span class="keyword">self</span> _dbGetItemWithKey:key excludeInlineData:<span class="literal">NO</span>];</span><br><span class="line">    <span class="keyword">if</span> (item) &#123;</span><br><span class="line">        <span class="comment">// 🔔❗️❗️❗️🔔❗️❗️❗️🔔❗️❗️❗️</span></span><br><span class="line">        <span class="comment">// 更新SQLite DB 中本条数据的 AccessTime</span></span><br><span class="line">        [<span class="keyword">self</span> _dbUpdateAccessTimeWithKey:key];</span><br><span class="line">        <span class="keyword">if</span> (item.filename) &#123;</span><br><span class="line">            item.value = [<span class="keyword">self</span> _fileReadWithName:item.filename];</span><br><span class="line">            <span class="keyword">if</span> (!item.value) &#123;</span><br><span class="line">                [<span class="keyword">self</span> _dbDeleteItemWithKey:key];</span><br><span class="line">                item = <span class="literal">nil</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// YYKVStorage.m</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)_dbUpdateAccessTimeWithKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *sql = <span class="string">@&quot;update manifest set last_access_time = ?1 where key = ?2;&quot;</span>;</span><br><span class="line">    sqlite3_stmt *stmt = [<span class="keyword">self</span> _dbPrepareStmt:sql];</span><br><span class="line">    <span class="keyword">if</span> (!stmt) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    sqlite3_bind_int(stmt, <span class="number">1</span>, (<span class="keyword">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    sqlite3_bind_text(stmt, <span class="number">2</span>, key.UTF8String, <span class="number">-1</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">int</span> result = sqlite3_step(stmt);</span><br><span class="line">    <span class="keyword">if</span> (result != SQLITE_DONE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_errorLogsEnabled) <span class="built_in">NSLog</span>(<span class="string">@&quot;%s line:%d sqlite update error (%d): %s&quot;</span>, __FUNCTION__, __LINE__, result, sqlite3_errmsg(_db));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行的<code>SQL</code>语句是：<br><code>update manifest set last_access_time = ?1 where key = ?2;</code></p><ul><li>更新本条数据的 <code>last_access_time</code>；</li><li>同样使用<code>sqlite3_stmt</code>执行<code>SQL</code>；</li></ul><blockquote><p>至此：YYDiskCache 中关于 LRU 的实现也就明朗了~</p></blockquote><h2 id="get-操作："><a href="#get-操作：" class="headerlink" title="get 操作："></a>get 操作：</h2><ul><li>每次在读取数据的时候，都会更新数据的<code>last_access_time</code>；</li></ul><h2 id="trim-操作"><a href="#trim-操作" class="headerlink" title="trim 操作"></a>trim 操作</h2><ul><li>① 当我们删减数据时，根据<code>last_access_time</code>升序取出<code>一定数量(每次16个)</code>的数据；</li><li>② 对取出的数据分别进行删除操作；<ul><li>对于<code>File</code>，还需要一并将<code>File</code>删除；</li></ul></li><li>③ 删除过程中，判断是否已经满足删减要求；未满足的话继续从①开始，直到满足删减要求；</li></ul></div><div class="post-copyright"><p class="copyright-item"> <span>Author:</span> <a href="http://yotrolz.com">YotrolZ</a></p><p class="copyright-item"> <span>Link:</span> <a href="http://yotrolz.com/posts/5c5f8fb2/">http://yotrolz.com/posts/5c5f8fb2/</a></p><p class="copyright-item"> <span>License:</span> <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a></p></div><footer class="post-footer"><nav class="post-nav"><a class="prev" href="/posts/ac25c853/"><i class="iconfont icon-left"></i> <span class="prev-text nav-default">YYCache源码学习-内存缓存分析</span> <span class="prev-text nav-mobile">Prev</span></a> <a class="next" href="/posts/ba9af90f/"><span class="next-text nav-default">YYCache源码学习-初始化分析</span> <span class="prev-text nav-mobile">Next</span><i class="iconfont icon-right"></i></a></nav></footer></article></div><div class="comments" id="comments"></div></div></main><footer id="footer" class="footer"><div class="social-links"></div><div class="copyright"> <span class="power-by">Powered by <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a></span> <span class="division">|</span> <span class="theme-info">Theme - <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/ahonn/hexo-theme-even">Even</a></span> <span class="copyright-year">&copy;2015 - 2022<span class="heart"><i class="iconfont icon-heart"></i></span> <span class="author">YotrolZ</span></span></div></footer><div class="back-to-top" id="back-to-top"><i class="iconfont icon-up"></i></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/yotrolz/yotrolz.github.io@gh/lib/jquery/jquery.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/yotrolz/yotrolz.github.io@gh/lib/slideout/slideout.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/yotrolz/yotrolz.github.io@gh/lib/fancybox/jquery.fancybox.pack.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/yotrolz/yotrolz.github.io@gh/js/src/even.js?v=2.11.0"></script></body></html>