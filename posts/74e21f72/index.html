<!DOCTYPE html>
<html lang="en">
  <head><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="RunLoop"/><meta name="keywords" content="RunLoop, YotrolZ" /><link rel="alternate" href="/atom.xml" title="YotrolZ" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.11.0" />
<link rel="canonical" href="http://yotrolz.com/posts/74e21f72/"/>

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0" />

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-138610487-3"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-138610487-3');
</script><script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":"","latex":false};
</script>

    <title>RunLoop - YotrolZ</title>
  <meta name="generator" content="Hexo 5.2.0"></head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">YotrolZ</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">Home
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">YotrolZ</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            Home
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><article class="post">
    <header class="post-header">
      <h1 class="post-title">RunLoop
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2015-07-14
        </span><span class="post-category">
            <a href="/categories/iOS/">iOS</a>
            </span>
        </div>
    </header>

    <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81RunLoop%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">一、RunLoop基本概念</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81RunLoop%E5%AF%B9%E8%B1%A1"><span class="toc-text">二、RunLoop对象</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81RunLoop%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-text">三、RunLoop与线程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81RunLoop%E7%9A%84%E7%BB%93%E6%9E%84-%E4%B8%BA%E6%9B%B4%E6%B7%B1%E5%85%A5%E7%9A%84%E4%BA%86%E8%A7%A3RunLoop%E6%88%91%E4%BB%AC%E7%A0%94%E7%A9%B6CFRunLoop"><span class="toc-text">四、RunLoop的结构(为更深入的了解RunLoop我们研究CFRunLoop)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-CFRunLoopModeRef"><span class="toc-text">1. CFRunLoopModeRef:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-CFRunLoopTimerRef"><span class="toc-text">2. CFRunLoopTimerRef</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-CFRunLoopSourceRef"><span class="toc-text">3. CFRunLoopSourceRef</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-CFRunLoopObserverRef"><span class="toc-text">4. CFRunLoopObserverRef</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81RunLoop%E7%9A%84%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91"><span class="toc-text">五、RunLoop的处理逻辑</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81RunLoop%E7%9A%84%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8"><span class="toc-text">六、RunLoop的具体使用</span></a></li></ol>
    </div>
  </div><div class="post-content"><h1 id="一、RunLoop基本概念"><a href="#一、RunLoop基本概念" class="headerlink" title="一、RunLoop基本概念"></a>一、RunLoop基本概念</h1><ul>
<li><p>RunLoop从字面意思上看:</p>
<ul>
<li>运行循环</li>
<li>跑圈</li>
</ul>
</li>
<li><p>RunLoop的基本作用:</p>
<ul>
<li>保持程序的持续运行</li>
<li>处理APP中各种事件(比如:触摸事件,定时器事件，Selector事件等)</li>
<li>能节省CPU资源，提高程序的性能:该做事的时候就唤醒，没有事情就睡眠<a id="more"></a></li>
</ul>
</li>
<li><p>假如没有了RunLoop:</p>
<ul>
<li>大家都知道程序的入口是main函数:<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>如果没有RunLoop，程序就会在main函数执行完毕的时候退出，也正是因为有了RunLoop，导致main函数没有马上退出,保证了程序持续运行;</li>
<li>其实是在<code>UIApplicationMain</code>函数内部启动了一个RunLoop;</li>
<li>这个默认启动的RunLoop是跟<code>主线程</code>相关联的</li>
</ul>
</li>
<li><p>RunLoop内部其实是有一个do-while循环(可以从RunLoop源码中找到),暂且可以理解为下面的代码:</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/YotrolZ/hexo/master/img/590107-d09ffc475292408f.png" alt="RunLoop伪代码.png"></p>
<h1 id="二、RunLoop对象"><a href="#二、RunLoop对象" class="headerlink" title="二、RunLoop对象"></a>二、RunLoop对象</h1><ul>
<li>iOS中有2套API来访问和使用RunLoop<ul>
<li>Foundation框架中的<code>NSRunLoop</code>;</li>
<li>Core Foundation中的<code>CFRunLoop</code>;</li>
</ul>
</li>
<li>NSRunLoop是基于CFRunLoopRef的一层OC包装，所以要了解RunLoop内部结构，需要多研究CFRunLoopRef层面的API（Core Foundation层面）</li>
</ul>
<h1 id="三、RunLoop与线程"><a href="#三、RunLoop与线程" class="headerlink" title="三、RunLoop与线程"></a>三、RunLoop与线程</h1><ul>
<li><p>每条线程都有<code>唯一</code>的一个与之对应的RunLoop对象</p>
</li>
<li><p>主线程中的RunLoop由<code>系统自动创建</code>，子线程中RunLoop可以通过手动创建</p>
</li>
<li><p>RunLoop在<code>线程结束</code>的时候会被销毁</p>
</li>
<li><p>获取RunLoop对象</p>
<ul>
<li>Foundation框架中<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">NSRunLoop</span> currentRunLoop]; <span class="comment">// 获得当前线程的RunLoop对象</span></span><br><span class="line">[<span class="built_in">NSRunLoop</span> mainRunLoop]; <span class="comment">// 获得主线程的RunLoop对象</span></span><br></pre></td></tr></table></figure></li>
<li>Core Foundation框架中<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFRunLoopGetCurrent</span>(); <span class="comment">// 获得当前线程的RunLoop对象</span></span><br><span class="line"><span class="built_in">CFRunLoopGetMain</span>(); <span class="comment">// 获得主线程的RunLoop对象</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h1 id="四、RunLoop的结构-为更深入的了解RunLoop我们研究CFRunLoop"><a href="#四、RunLoop的结构-为更深入的了解RunLoop我们研究CFRunLoop" class="headerlink" title="四、RunLoop的结构(为更深入的了解RunLoop我们研究CFRunLoop)"></a>四、RunLoop的结构(为更深入的了解RunLoop我们研究CFRunLoop)</h1><p><img src="https://raw.githubusercontent.com/YotrolZ/hexo/master/img/590107-50c0f0f61eaa2bca.png" alt="RunLoop结构.png"></p>
<h2 id="1-CFRunLoopModeRef"><a href="#1-CFRunLoopModeRef" class="headerlink" title="1. CFRunLoopModeRef:"></a>1. CFRunLoopModeRef:</h2><ul>
<li><code>CFRunLoopModeRef</code>代表RunLoop的<code>运行模式</code></li>
<li>一个RunLoop中包含N多个Mode，每个Mode中又包含了N多个<code>Source/Timer/Observer</code></li>
<li>一个RunLoop在同一时间内只能处在一种运行模式下，这个模式也就是<code>CurrentMode</code></li>
<li>一个RunLoop的运行模式可以<code>切换</code>，是在当前Mode退出后，下次进入的时候切换</li>
<li>系统默认注册了5中Mode:<ul>
<li><code>NSDefaultRunLoopMode</code>:默认的Mode，通常主线程的RunLoop是在这个Mode下运行</li>
<li><code>UITrackingRunLoopMode</code>:界面跟踪Mode，当用户与界面交互的时候会在此Mode下运行</li>
<li><code>NSRunLoopCommonModes</code>:这个不是一种真正的Mode，是一个占位用的Mode</li>
<li><code>UIInitializationRunLoopMode</code>:程序启动时的Mode，启动完成后就不在此Mode下</li>
<li><code>GSEventReceiveRunLoopMode</code>:接受系统事件的内部Mode，一般我们用不到</li>
</ul>
</li>
</ul>
<h2 id="2-CFRunLoopTimerRef"><a href="#2-CFRunLoopTimerRef" class="headerlink" title="2. CFRunLoopTimerRef"></a>2. CFRunLoopTimerRef</h2><ul>
<li><p>CFRunLoopTimerRef是基于时间的触发器</p>
</li>
<li><p>CFRunLoopTimerRef基本上说的就是<code>NSTimer</code>，它<code>受RunLoop Mode的影响</code></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个定时器(NSDefaultRunLoopMode)</span></span><br><span class="line"><span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">2.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line"><span class="comment">// NSDefaultRunLoopMode:NSTimer只有在默认模式下(NSDefaultRunLoopMode)工作，切换到其他模式不再工作，比如拖拽了界面上的某个控件(会切换成UITrackingRunLoopMode)</span></span><br><span class="line">[[<span class="built_in">NSRunLoop</span> mainRunLoop] addTimer:timer forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 创建一个定时器(UITrackingRunLoopMode)</span></span><br><span class="line"><span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">2.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line"><span class="comment">// 拖拽UI界面时出发定时器,在默认模式(NSDefaultRunLoopMode)下不工作</span></span><br><span class="line">[[<span class="built_in">NSRunLoop</span> mainRunLoop] addTimer:timer forMode:<span class="built_in">UITrackingRunLoopMode</span>];</span><br><span class="line">       </span><br><span class="line"><span class="comment">// 创建一个定时器(NSRunLoopCommonModes)</span></span><br><span class="line"><span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">2.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line"><span class="comment">// NSRunLoopCommonModes仅仅是标记NSTimer在两种模式(UITrackingRunLoopMode/NSDefaultRunLoopMode)下都能运行,但一个RunLoop中同一时间内只能运行一种模式</span></span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认已经添加到主线程中RunLoop(mainRunLoop)中(Mode:NSDefaultRunLoopMode)</span></span><br><span class="line">[<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">2.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>GCD定时器不受RunLoop Mode的影响</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 定时器对象 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>)dispatch_source_t timer; <span class="comment">// 需要一个强引用</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;开始&quot;</span>);</span><br><span class="line"><span class="comment">// 获取队并发队列，定时器的回调函数将会在子线程中执行</span></span><br><span class="line"><span class="comment">// dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 获取主队列，定时器的回调函数将会在子线程中执行</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, queue);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 该时间表示从现在开始推迟两秒</span></span><br><span class="line">dispatch_time_t start = dispatch_time(DISPATCH_TIME_NOW, <span class="number">2</span> * <span class="built_in">NSEC_PER_SEC</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 设置定时器的开始时间，间隔时间</span></span><br><span class="line">dispatch_source_set_timer(<span class="keyword">self</span>.timer, start, <span class="number">1</span> * <span class="built_in">NSEC_PER_SEC</span>, <span class="number">0</span> * <span class="built_in">NSEC_PER_SEC</span>);</span><br><span class="line">    dispatch_source_set_event_handler(<span class="keyword">self</span>.timer, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;------%@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">dispatch_resume(<span class="keyword">self</span>.timer);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 参数说明:</span></span><br><span class="line"><span class="comment">// 设置定时器的一些属性</span></span><br><span class="line"><span class="comment">    dispatch_source_set_timer(dispatch_source_t source, // 定时器对象</span></span><br><span class="line"><span class="comment">                              dispatch_time_t start, // 定时器开始执行的时间</span></span><br><span class="line"><span class="comment">                              uint64_t interval, // 定时器的间隔时间</span></span><br><span class="line"><span class="comment">                              uint64_t leeway // 定时器的精度</span></span><br><span class="line"><span class="comment">                              );</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="3-CFRunLoopSourceRef"><a href="#3-CFRunLoopSourceRef" class="headerlink" title="3. CFRunLoopSourceRef"></a>3. CFRunLoopSourceRef</h2></li>
<li><p>按照官方文档CFRunLoopSourceRef为3类</p>
<ul>
<li>Port-Based Sources:与内核相关</li>
<li>Custom Input Sources:与自定义Sources相关</li>
<li>Cocoa Perform Selector Sources:与<code>Performxxxxxx</code>等方法等相关</li>
</ul>
</li>
<li><p>按照函数调用栈CFRunLoopSourceRef分2类:</p>
<ul>
<li><code>Source0</code>：非基于Port的</li>
<li><code>Source1</code>：基于Port的，通过内核和其他线程通信，接收、分发系统事件</li>
</ul>
</li>
</ul>
<h2 id="4-CFRunLoopObserverRef"><a href="#4-CFRunLoopObserverRef" class="headerlink" title="4. CFRunLoopObserverRef"></a>4. CFRunLoopObserverRef</h2><ul>
<li><p><code>CFRunLoopObserverRef</code>是RunLoop的<code>观察者</code>，可以通过CFRunLoopObserverRef来监听<code>RunLoop状态</code>的改变</p>
</li>
<li><p>CFRunLoopObserverRef监听的状态由以下几种:</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Run Loop Observer Activities */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">CF_OPTIONS</span>(<span class="built_in">CFOptionFlags</span>, <span class="built_in">CFRunLoopActivity</span>) &#123;</span><br><span class="line">    kCFRunLoopEntry = (<span class="number">1</span>UL &lt;&lt; <span class="number">0</span>),         <span class="comment">// 状态值:1,表示进入RunLoop</span></span><br><span class="line">    kCFRunLoopBeforeTimers = (<span class="number">1</span>UL &lt;&lt; <span class="number">1</span>),  <span class="comment">// 状态值:2,表示即将处理NSTimer</span></span><br><span class="line">    kCFRunLoopBeforeSources = (<span class="number">1</span>UL &lt;&lt; <span class="number">2</span>), <span class="comment">// 状态值:4,表示即将处理Sources</span></span><br><span class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1</span>UL &lt;&lt; <span class="number">5</span>), <span class="comment">// 状态值:32,表示即将休眠</span></span><br><span class="line">    kCFRunLoopAfterWaiting = (<span class="number">1</span>UL &lt;&lt; <span class="number">6</span>),  <span class="comment">// 状态值:64,表示从休眠中唤醒</span></span><br><span class="line">    kCFRunLoopExit = (<span class="number">1</span>UL &lt;&lt; <span class="number">7</span>),          <span class="comment">// 状态值:128,表示退出RunLoop</span></span><br><span class="line">    kCFRunLoopAllActivities = <span class="number">0x0FFFFFFF</span>U <span class="comment">// 表示监听上面所有的状态</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如何监听RunLoop的状态:</p>
<ul>
<li><p>1.创建CFRunLoopObserverRef</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个参数用于分配该observer对象的内存</span></span><br><span class="line"><span class="comment">// 第二个参数用以设置该observer所要关注的的事件，详见回调函数myRunLoopObserver中注释</span></span><br><span class="line"><span class="comment">// 第三个参数用于标识该observer是在第一次进入run loop时执行还是每次进入run loop处理时均执行</span></span><br><span class="line"><span class="comment">// 第四个参数用于设置该observer的优先级,一般为0</span></span><br><span class="line"><span class="comment">// 第五个参数用于设置该observer的回调函数</span></span><br><span class="line"><span class="comment">// 第六个参数observer的运行状态   </span></span><br><span class="line"><span class="built_in">CFRunLoopObserverRef</span> observer = <span class="built_in">CFRunLoopObserverCreateWithHandler</span> (<span class="built_in">CFAllocatorGetDefault</span>(), kCFRunLoopAllActivities, <span class="literal">YES</span>, <span class="number">0</span>, ^(<span class="built_in">CFRunLoopObserverRef</span>    observer, <span class="built_in">CFRunLoopActivity</span> activity) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;----监听到RunLoop状态发生改变---%zd&quot;</span>, activity);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>2.将观察者CFRunLoopObserverRef添加到RunLoop上面</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), observer, kCFRunLoopDefaultMode);</span><br></pre></td></tr></table></figure>
</li>
<li><p>3.观察者CFRunLoopObserverRef要<code>手动释放</code></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFRelease</span>(observer);</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h1 id="五、RunLoop的处理逻辑"><a href="#五、RunLoop的处理逻辑" class="headerlink" title="五、RunLoop的处理逻辑"></a>五、RunLoop的处理逻辑</h1><p><img src="https://raw.githubusercontent.com/YotrolZ/hexo/master/img/590107-1a9fc347f329b2d4.png" alt="RunLoop处理逻辑-官方.png"></p>
<ul>
<li><p>上图显示了线程的<code>输入源</code></p>
<ul>
<li>1.基于端口的输入源（Port Sources）</li>
<li>2.自定义输入源（Custom Sources）</li>
<li>3.Cocoa执行Selector的源（<code>performSelectorxxxx</code>方法）</li>
<li>4.定时源（Timer Sources ）</li>
</ul>
</li>
<li><p>线程针对上面不同的输入源，有不同的<code>处理机制</code></p>
<ul>
<li>1.handlePort——处理基于<code>端口</code>的输入源</li>
<li>2.customSrc——处理用户<code>自定义</code>输入源</li>
<li>3.mySelector——处理<code>Selector</code>的源</li>
<li>4.timerFired——处理<code>定时</code>源</li>
</ul>
</li>
</ul>
<ul>
<li>非官方文档<br><img src="https://raw.githubusercontent.com/YotrolZ/hexo/master/img/590107-cc0dcab518e185d9.png" alt="RunLoop处理逻辑-非官方.png"></li>
</ul>
<h1 id="六、RunLoop的具体使用"><a href="#六、RunLoop的具体使用" class="headerlink" title="六、RunLoop的具体使用"></a>六、RunLoop的具体使用</h1><ul>
<li><p>1.图片刷新(假如界面要刷新N多图片(渲染)，此时用户拖拽UI控件就会出现卡的效果，我们可以通过RunLoop实现，只在RunLoop默认Mode下下载，也就是拖拽Mode下不刷新图片)</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// 只在NSDefaultRunLoopMode下执行(刷新图片)</span></span><br><span class="line">    [<span class="keyword">self</span>.myImageView performSelector:<span class="keyword">@selector</span>(setImage:) withObject:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@&quot;0&quot;</span>] afterDelay:<span class="number">2.0</span> inModes:@[<span class="built_in">NSDefaultRunLoopMode</span>]];    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>2.保证一个线程永远不死</p>
<ul>
<li><p>方案一:用一个强引用引用住线程(这种方案是不可行的)，原因如下:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;ViewController.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;YCThread.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路:用一个强引用线程，当点击屏幕的时候再让他启动，结果是不可行！！！！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">因为，线程执行完内部的任务后就会自动死亡，你如果用一个强引用引用这个线程，</span></span><br><span class="line"><span class="comment">即使内存还在，但是该线程也已经处于死亡状态(线程状态)，是不能再次启动的，</span></span><br><span class="line"><span class="comment">如果再次启动一个死亡状态的线程，就会</span></span><br><span class="line"><span class="comment">报错--reason: &#x27;*** -[YCThread start]: attempt(视图) to start the thread again&#x27;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/** 线程对象 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>)YCThread *thread; <span class="comment">// 强引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// 创建子线程</span></span><br><span class="line">    <span class="keyword">self</span>.thread = [[YCThread alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run)     object:<span class="literal">nil</span>];</span><br><span class="line">    <span class="comment">// 启动子线程</span></span><br><span class="line">    [<span class="keyword">self</span>.thread start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)run &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;----------&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="comment">// 点击屏幕再次启动线程</span></span><br><span class="line">    [<span class="keyword">self</span>.thread start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>方案二:(死循环+RunLoop)，不建议此做法，不是太好</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;ViewController.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="comment">/** 线程对象 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>)<span class="built_in">NSThread</span> *thread;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子线程</span></span><br><span class="line">    <span class="keyword">self</span>.thread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run)     object:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span>.thread start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)run &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;run--%@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用死循环(不建议此做法)</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        [[<span class="built_in">NSRunLoop</span> currentRunLoop] run];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(test) onThread:<span class="keyword">self</span>.thread withObject:<span class="literal">nil</span>   waitUntilDone:<span class="literal">YES</span> modes:@[<span class="built_in">NSDefaultRunLoopMode</span>]];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)test &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;test--%@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>方案三:（子线程中加入RunLoop+RunLoop源）建议采用此方案</p>
<ul>
<li>备注:RunLoop源:<code>Port</code>、<code>Sources0/Sources1</code>、<code>Timer</code></li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;ViewController.h&quot;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路:为了保证线程不死，我们考虑在子线程中加入RunLoop，</span></span><br><span class="line"><span class="comment">    但是由于RunLoop中没有没有源，就会自动退出RunLoop，</span></span><br><span class="line"><span class="comment">    所以我们要为子线程添加一个RunLoop，</span></span><br><span class="line"><span class="comment">    并且为这个RunLoop添加源(保证RunLoop不退出)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 线程对象 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>)<span class="built_in">NSThread</span> *thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建子线程</span></span><br><span class="line">    <span class="keyword">self</span>.thread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run)        object:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动子线程</span></span><br><span class="line">    [<span class="keyword">self</span>.thread start];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)run &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;run--%@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]); <span class="comment">// 子线程</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 给子线程添加一个RunLoop，并且加入源</span></span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:[<span class="built_in">NSPort</span> port] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">    <span class="comment">// 启动RunLoop</span></span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] run];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;------------&quot;</span>); <span class="comment">// RunLoop启动，这句没有执行的机会</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在子线程中调用test方法，如果子线程还在就能够调用成功</span></span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(test) onThread:<span class="keyword">self</span>.thread withObject:<span class="literal">nil</span>      waitUntilDone:<span class="literal">YES</span> modes:@[<span class="built_in">NSDefaultRunLoopMode</span>]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)test &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;test--%@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]); <span class="comment">// 子线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<ul>
<li>主线程之所以没有退出，就是因为主线程内部自动开启了一个RunLoop.</li>
</ul>
</li>
</ul>
</li>
</ul>

      </div>
      <div class="post-copyright">
    <p class="copyright-item">
      <span>Author: </span>
      <a href="http://yotrolz.com">YotrolZ</a>
    </p>
    <p class="copyright-item">
      <span>Link: </span>
      <a href="http://yotrolz.com/posts/74e21f72/">http://yotrolz.com/posts/74e21f72/</a>
    </p>
    <p class="copyright-item">
      <span>License: </span><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>
      <footer class="post-footer">
        <div class="post-tags">
            <a href="/tags/RunLoop/">RunLoop</a>
            </div>
        
        <nav class="post-nav"><a class="prev" href="/posts/c6b5a9b8/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">本地Git仓库和远程仓库的创建及关联</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    <a class="next" href="/posts/c8aae65b/">
        <span class="next-text nav-default">iOS多线程的4种实现方案</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></footer>
    </article></div><div class="comments" id="comments"></div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"></div><div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">&copy;2015 - 2020<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">YotrolZ</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
</body>
</html>
