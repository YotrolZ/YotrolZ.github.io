<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="theme-color" content="#f8f5ec"><meta name="msapplication-navbutton-color" content="#f8f5ec"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec"><meta name="description" content="YYMemoryCache 是一个快速的内存缓存，用于存储键值对。API和性能类似于`NSCache`。所有方法都是`线程安全`的；采用`LRU`来移除数据；可配置为当收到`内存警告`或`app进入后台`时自动清除对象；读取操作相关的api的时间复杂度为O(1)。"><link rel="alternate" href="/atom.xml" title="YotrolZ" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.11.0"><link rel="canonical" href="http://yotrolz.com/posts/ac25c853/"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/yotrolz/yotrolz.github.io@gh/lib/fancybox/jquery.fancybox.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/yotrolz/yotrolz.github.io@gh/css/style.css?v=2.11.0"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-138610487-3"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-138610487-3")</script><script id="baidu_push">!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script src="//cdn.jsdelivr.net/npm/leancloud-storage@4.10.0/dist/av-min.js"></script><script id="leancloud">AV.init({appId:"mqfPQEKBtui9puAJUkYFY7Jn-MdYXbMMI",appKey:"A6R0T4bEvcBsTU8pB7NhJ6Wl"})</script><script>window.config={leancloud:{show_visits:!1,app_id:"mqfPQEKBtui9puAJUkYFY7Jn-MdYXbMMI",app_key:"A6R0T4bEvcBsTU8pB7NhJ6Wl"},toc:!0,fancybox:!0,pjax:"",latex:!1}</script><title>YYCache源码学习-内存缓存分析 - YotrolZ</title><meta name="generator" content="Hexo 5.4.1"></head><body><div id="mobile-navbar" class="mobile-navbar"><div class="mobile-header-logo"> <a href="/." class="logo">YotrolZ</a></div><div class="mobile-navbar-icon"><span></span><span></span><span></span></div></div><nav id="mobile-menu" class="mobile-menu slideout-menu"><ul class="mobile-menu-list"><a href="/"><li class="mobile-menu-item">Home</li></a><a href="/archives/"><li class="mobile-menu-item">Archives</li></a><a href="/tags/"><li class="mobile-menu-item">Tags</li></a><a href="/categories/"><li class="mobile-menu-item">Categories</li></a></ul></nav><div class="container" id="mobile-panel"><header id="header" class="header"><div class="logo-wrapper"> <a href="/." class="logo">YotrolZ</a></div><nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item"> <a class="menu-item-link" href="/">Home</a></li><li class="menu-item"> <a class="menu-item-link" href="/archives/">Archives</a></li><li class="menu-item"> <a class="menu-item-link" href="/tags/">Tags</a></li><li class="menu-item"> <a class="menu-item-link" href="/categories/">Categories</a></li></ul></nav></header><main id="main" class="main"><div class="content-wrapper"><div id="content" class="content"><article class="post"><header class="post-header"><h1 class="post-title">YYCache源码学习-内存缓存分析</h1><div class="post-meta"> <span class="post-time">2019-10-29</span> <span class="post-visits" style="display:none" data-url="/posts/ac25c853/" data-title="YYCache源码学习-内存缓存分析">Visits 0</span></div></header><div class="post-toc" id="post-toc"><h2 class="post-toc-title">Contents</h2><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#YYMemoryCache-%E7%AE%80%E4%BB%8B"><span class="toc-text">YYMemoryCache 简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#YYMemoryCache-%E6%BA%90%E7%A0%81%E6%80%BB%E8%A7%88"><span class="toc-text">YYMemoryCache 源码总览</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#YYMemoryCache-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">YYMemoryCache 初始化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#YYMemoryCache-%E5%AE%9A%E6%97%B6%E6%8E%A2%E6%B5%8B%E6%9C%BA%E5%88%B6"><span class="toc-text">YYMemoryCache 定时探测机制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#YYLinkedMap-amp-YYLinkedMapNode"><span class="toc-text">_YYLinkedMap &amp; _YYLinkedMapNode</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#YYMemoryCache-LRU"><span class="toc-text">YYMemoryCache LRU</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#trimToCount"><span class="toc-text">trimToCount</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E9%87%8A%E6%94%BE%E5%AF%B9%E8%B1%A1"><span class="toc-text">异步释放对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#removeTailNode"><span class="toc-text">removeTailNode</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#objectForKey"><span class="toc-text">objectForKey</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bringNodeToHead"><span class="toc-text">bringNodeToHead</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#YYMemoryCache%E8%AF%BB%E5%8F%96%E6%93%8D%E4%BD%9C%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6O-1"><span class="toc-text">YYMemoryCache读取操作时间复杂度O(1)</span></a></li></ol></div></div><div class="post-content"><p>在<a href="https://yotrolz.com/posts/ba9af90f/">上一篇文章</a>中，我们对<code>YYCache</code>的初始化操作了做了简单分析，具体代码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// YYCache.m</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithPath:(<span class="built_in">NSString</span> *)path &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ① 初始化磁盘缓存</span></span><br><span class="line">    YYDiskCache *diskCache = [[YYDiskCache alloc] initWithPath:path];</span><br><span class="line">    <span class="keyword">if</span> (!diskCache) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *name = [path lastPathComponent];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ② 初始化内存缓存</span></span><br><span class="line">    YYMemoryCache *memoryCache = [YYMemoryCache new];</span><br><span class="line">    memoryCache.name = name;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ③ 初始化本身并对内部的三个只读属性进行赋值</span></span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    _name = name;</span><br><span class="line">    _diskCache = diskCache;</span><br><span class="line">    _memoryCache = memoryCache;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>本篇文章我们介绍一下 <code>YYMemoryCache</code> 磁盘缓存的实现</p></blockquote><h1 id="YYMemoryCache-简介"><a href="#YYMemoryCache-简介" class="headerlink" title="YYMemoryCache 简介"></a>YYMemoryCache 简介</h1><p>先来看一下官方介绍(可在源码中查阅):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">`YYMemoryCache`是一种快速的`内存缓存`，用于存储`键值对`。</span><br><span class="line">与NSDictionary不同，key是retain的，而不是copy(必须符合NSCopying协议)的。</span><br><span class="line">API和性能类似于`NSCache`，所有方法都是`线程安全`的。</span><br><span class="line"></span><br><span class="line">YYMemoryCache对象与NSCache在以下几个方面有所不同:</span><br><span class="line">- 它使用LRU(最近最少使用)删除对象;NSCache驱逐的方法</span><br><span class="line">是不确定的。</span><br><span class="line">- 可通过cost、count、age进行控制;NSCache的限制并不精确。</span><br><span class="line">- 可配置为当收到内存警告或app进入后台时自动清除对象。</span><br><span class="line"></span><br><span class="line">`YYMemoryCache`中读取操作相关的api的时间复杂度O(1)。</span><br></pre></td></tr></table></figure><h1 id="YYMemoryCache-源码总览"><a href="#YYMemoryCache-源码总览" class="headerlink" title="YYMemoryCache 源码总览"></a>YYMemoryCache 源码总览</h1><p><img src="https://cdn.jsdelivr.net/gh/yotrolz/image@master/blog/YYCache/YYMemoryCache.png" alt="YYMemoryCache API"></p><h1 id="YYMemoryCache-初始化"><a href="#YYMemoryCache-初始化" class="headerlink" title="YYMemoryCache 初始化"></a>YYMemoryCache 初始化</h1><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YYMemoryCache</span> </span>&#123;</span><br><span class="line">    pthread_mutex_t _lock;</span><br><span class="line">    _YYLinkedMap *_lru;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> _queue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = <span class="keyword">super</span>.init;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化锁</span></span><br><span class="line">    pthread_mutex_init(&amp;_lock, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双向链表结构(下文深入分析)</span></span><br><span class="line">    _lru = [_YYLinkedMap new];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义的一个串行队列</span></span><br><span class="line">    _queue = dispatch_queue_create(<span class="string">&quot;com.ibireme.cache.memory&quot;</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 缓存极限值</span></span><br><span class="line">    _countLimit = <span class="built_in">NSUIntegerMax</span>;</span><br><span class="line">    _costLimit = <span class="built_in">NSUIntegerMax</span>;</span><br><span class="line">    _ageLimit = DBL_MAX;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自动检查时间间隔；默认：5秒</span></span><br><span class="line">    <span class="comment">// 一个内部计时器，来检查缓存是否到达极限，如果达到极限，就开始删除数据</span></span><br><span class="line">    _autoTrimInterval = <span class="number">5.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置是否在内存警告及进入后台时清除数据；默认：开启</span></span><br><span class="line">    _shouldRemoveAllObjectsOnMemoryWarning = <span class="literal">YES</span>;</span><br><span class="line">    _shouldRemoveAllObjectsWhenEnteringBackground = <span class="literal">YES</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 监听了内存警告及进入后台的两个通知</span></span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(_appDidReceiveMemoryWarningNotification) name:<span class="built_in">UIApplicationDidReceiveMemoryWarningNotification</span> object:<span class="literal">nil</span>];</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(_appDidEnterBackgroundNotification) name:<span class="built_in">UIApplicationDidEnterBackgroundNotification</span> object:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归删减数据(和上文的 _autoTrimInterval 配合使用)</span></span><br><span class="line">    [<span class="keyword">self</span> _trimRecursively];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="YYMemoryCache-定时探测机制"><a href="#YYMemoryCache-定时探测机制" class="headerlink" title="YYMemoryCache 定时探测机制"></a>YYMemoryCache 定时探测机制</h1><ul><li><code>YYMemoryCache</code> 内部有一个定时任务，用来检查缓存是否到达极限，如果达到极限，就开始删除数据</li><li>在<code>YYMemoryCache</code>初始化的时候，初始化了 <code>_autoTrimInterval = 5.0;</code> 即：定时周期默认为5秒。</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// YYMemoryCache.m</span></span><br><span class="line">- (<span class="keyword">void</span>)_trimRecursively &#123;</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) _<span class="keyword">self</span> = <span class="keyword">self</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 🔔❗️❗️❗️ 🔔❗️❗️❗️</span></span><br><span class="line">    <span class="comment">// dispatch_after: 5秒后调用</span></span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(_autoTrimInterval * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, <span class="number">0</span>), ^&#123;</span><br><span class="line">        __<span class="keyword">strong</span> <span class="keyword">typeof</span>(_<span class="keyword">self</span>) <span class="keyword">self</span> = _<span class="keyword">self</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">self</span>) <span class="keyword">return</span>;</span><br><span class="line">        [<span class="keyword">self</span> _trimInBackground]; <span class="comment">// 删减数据的操作</span></span><br><span class="line">        [<span class="keyword">self</span> _trimRecursively];  <span class="comment">// 递归调用</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删减数据的操作</span></span><br><span class="line">- (<span class="keyword">void</span>)_trimInBackground &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(_queue, ^&#123;</span><br><span class="line">        [<span class="keyword">self</span> _trimToCost:<span class="keyword">self</span>-&gt;_costLimit];</span><br><span class="line">        [<span class="keyword">self</span> _trimToCount:<span class="keyword">self</span>-&gt;_countLimit];</span><br><span class="line">        [<span class="keyword">self</span> _trimToAge:<span class="keyword">self</span>-&gt;_ageLimit];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>YYMemoryCache</code>定时探测机制：</p><ul><li>默认5秒一次探测；<code>_autoTrimInterval = 5.0;</code></li><li>使用<code>dispatch_after</code> + <code>递归调用</code> 实现定时探测；</li><li><code>dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0)</code>：低优先级的全局队列</li></ul><h1 id="YYLinkedMap-amp-YYLinkedMapNode"><a href="#YYLinkedMap-amp-YYLinkedMapNode" class="headerlink" title="_YYLinkedMap &amp; _YYLinkedMapNode"></a>_YYLinkedMap &amp; _YYLinkedMapNode</h1><p><code>_YYLinkedMap</code> &amp; <code>_YYLinkedMapNode</code>为内部私有类；</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">_YYLinkedMap</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">@package</span></span><br><span class="line">    <span class="built_in">CFMutableDictionaryRef</span> _dic; <span class="comment">// do not set object directly</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> _totalCost;</span><br><span class="line">    <span class="built_in">NSUInteger</span> _totalCount;</span><br><span class="line">    _YYLinkedMapNode *_head; <span class="comment">// MRU, do not change it directly</span></span><br><span class="line">    _YYLinkedMapNode *_tail; <span class="comment">// LRU, do not change it directly</span></span><br><span class="line">    <span class="built_in">BOOL</span> _releaseOnMainThread;</span><br><span class="line">    <span class="built_in">BOOL</span> _releaseAsynchronously;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 在头部插入一个node，并更新 total cost</span></span><br><span class="line">- (<span class="keyword">void</span>)insertNodeAtHead:(_YYLinkedMapNode *)node;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 将node移动到头部(这个节点需要已经存在于dic中)</span></span><br><span class="line">- (<span class="keyword">void</span>)bringNodeToHead:(_YYLinkedMapNode *)node;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 移除一个node(这个节点需要已经存在于dic中)</span></span><br><span class="line">- (<span class="keyword">void</span>)removeNode:(_YYLinkedMapNode *)node;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 移除尾部node(如果存在的话)</span></span><br><span class="line">- (_YYLinkedMapNode *)removeTailNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 移除全部node，并且在后台队列</span></span><br><span class="line">- (<span class="keyword">void</span>)removeAll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">_YYLinkedMapNode</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">@package</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> _YYLinkedMapNode *_prev; <span class="comment">// retained by dic</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> _YYLinkedMapNode *_next; <span class="comment">// retained by dic</span></span><br><span class="line">    <span class="keyword">id</span> _key;</span><br><span class="line">    <span class="keyword">id</span> _value;</span><br><span class="line">    <span class="built_in">NSUInteger</span> _cost;</span><br><span class="line">    <span class="built_in">NSTimeInterval</span> _time;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><ul><li>由于 <code>_YYLinkedMapNode</code>对象已经存在于<code>_dic</code>内，且被<code>retain</code> ,<code>_YYLinkedMapNode</code>对象内部的<code>_prev</code> 和 <code>_next</code> 使用的是<code>__unsafe_unretained</code>;</li></ul><p><img src="https://cdn.jsdelivr.net/gh/yotrolz/image@master/blog/YYCache/YYLinkedMap.jpg" alt="_YYLinkedMapNode"></p><h1 id="YYMemoryCache-LRU"><a href="#YYMemoryCache-LRU" class="headerlink" title="YYMemoryCache LRU"></a>YYMemoryCache LRU</h1><p>从以下<code>四个</code>API来讲解 <code>YYMemoryCache</code> <code>LRU</code>;</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)trimToCount:(<span class="built_in">NSUInteger</span>)count;  <span class="comment">// YYMemoryCache</span></span><br><span class="line"></span><br><span class="line">- (_YYLinkedMapNode *)removeTailNode;   <span class="comment">// _YYLinkedMap</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)objectForKey:(<span class="keyword">id</span>)key;    <span class="comment">// YYMemoryCache</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)bringNodeToHead:(_YYLinkedMapNode *)node; <span class="comment">// _YYLinkedMap</span></span><br></pre></td></tr></table></figure><h2 id="trimToCount"><a href="#trimToCount" class="headerlink" title="trimToCount"></a>trimToCount</h2><ul><li>内部会调用<code>removeTailNode</code>, 下文分析</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// YYMemoryCache.m</span></span><br><span class="line">- (<span class="keyword">void</span>)trimToCount:(<span class="built_in">NSUInteger</span>)count &#123;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span> removeAllObjects];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> _trimToCount:count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// YYMemoryCache.m</span></span><br><span class="line">- (<span class="keyword">void</span>)_trimToCount:(<span class="built_in">NSUInteger</span>)countLimit &#123;</span><br><span class="line">    <span class="built_in">BOOL</span> finish = <span class="literal">NO</span>;</span><br><span class="line">    pthread_mutex_lock(&amp;_lock);</span><br><span class="line">    <span class="keyword">if</span> (countLimit == <span class="number">0</span>) &#123;</span><br><span class="line">        [_lru removeAll];</span><br><span class="line">        finish = <span class="literal">YES</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_lru-&gt;_totalCount &lt;= countLimit) &#123;</span><br><span class="line">        finish = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;_lock);</span><br><span class="line">    <span class="keyword">if</span> (finish) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSMutableArray</span> *holder = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">    <span class="keyword">while</span> (!finish) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pthread_mutex_trylock(&amp;_lock) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果当前存储的 count 超标 就移除尾部节点， 直到符合要求</span></span><br><span class="line">            <span class="keyword">if</span> (_lru-&gt;_totalCount &gt; countLimit) &#123;</span><br><span class="line">                <span class="comment">// 🔔❗️❗️❗️ 🔔❗️❗️❗️</span></span><br><span class="line">                _YYLinkedMapNode *node = [_lru removeTailNode];</span><br><span class="line">                <span class="keyword">if</span> (node) [holder addObject:node];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                finish = <span class="literal">YES</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pthread_mutex_unlock(&amp;_lock);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            usleep(<span class="number">10</span> * <span class="number">1000</span>); <span class="comment">//10 ms</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (holder.count) &#123;</span><br><span class="line">        <span class="built_in">dispatch_queue_t</span> queue = _lru-&gt;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();</span><br><span class="line">        <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">            [holder count]; <span class="comment">// release in queue</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异步释放对象"><a href="#异步释放对象" class="headerlink" title="异步释放对象"></a>异步释放对象</h3><blockquote><p><code>YYMemoryCacheGetReleaseQueue()</code></p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="built_in">dispatch_queue_t</span> YYMemoryCacheGetReleaseQueue() &#123;</span><br><span class="line">    <span class="keyword">return</span> dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用了一个<code>低优先级(DISPATCH_QUEUE_PRIORITY_LOW)</code> 的 <code>全局并发队列</code>;</li><li>使用 <code>static</code> <code>inline</code> 关键字已提高执行效率；</li></ul><blockquote><p>static inline 静态内联函数</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">通过声明一个内联函数，可以指示GCC更快地调用该函数。</span><br><span class="line">GCC可以做到这一点的一种方法是将该函数的代码集成到其调用者的代码中。</span><br><span class="line">这样可以消除函数调用的开销，从而加快执行速度。</span><br><span class="line">此外，如果任何实际参数值是恒定的，则它们的已知值可能会在编译时进行简化，因此不必包括所有内联函数的代码。</span><br><span class="line">对代码大小的影响难以预测。根据具体情况，使用函数内联可以使目标代码更大或更小。</span><br></pre></td></tr></table></figure><p><em>引用自：<a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc/Inline.html">An Inline Function is As Fast As a Macro</a></em></p><blockquote><p>在<code>iOS 保持界面流畅的技巧</code>文章中作者提到:</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对象的销毁虽然消耗资源不多，但累积起来也是不容忽视的。</span></span><br><span class="line"><span class="comment">通常当容器类持有大量对象时，其销毁时的资源消耗就非常明显。</span></span><br><span class="line"><span class="comment">同样的，如果对象可以放到后台线程去释放，那就挪到后台线程去。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这里有个小 Tip：</span></span><br><span class="line"><span class="comment">把对象捕获到 block 中，然后扔到后台队列去随便发送个消息以避免编译器警告</span></span><br><span class="line"><span class="comment">就可以让对象在后台线程销毁了。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSArray</span> *tmp = <span class="keyword">self</span>.array;</span><br><span class="line"><span class="keyword">self</span>.array = <span class="literal">nil</span>;</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    [tmp <span class="keyword">class</span>];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="removeTailNode"><a href="#removeTailNode" class="headerlink" title="removeTailNode"></a>removeTailNode</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// YYMemoryCache.m</span></span><br><span class="line">- (_YYLinkedMapNode *)removeTailNode &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_tail) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 _tail 尾部节点</span></span><br><span class="line">    _YYLinkedMapNode *tail = _tail;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从CFDictionary中移除</span></span><br><span class="line">    <span class="built_in">CFDictionaryRemoveValue</span>(_dic, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(_tail-&gt;_key));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新容量等信息</span></span><br><span class="line">    _totalCost -= _tail-&gt;_cost;</span><br><span class="line">    _totalCount--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新计算 _tail 尾部节点 </span></span><br><span class="line">    <span class="keyword">if</span> (_head == _tail) &#123;</span><br><span class="line">        _head = _tail = <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _tail = _tail-&gt;_prev;</span><br><span class="line">        _tail-&gt;_next = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 _tail 尾部节点返回(更新前的_tail)</span></span><br><span class="line">    <span class="keyword">return</span> tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="objectForKey"><a href="#objectForKey" class="headerlink" title="objectForKey"></a>objectForKey</h2><ul><li>内部会调用<code>bringNodeToHead</code>, 下文分析</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// YYMemoryCache.m</span></span><br><span class="line">- (<span class="keyword">id</span>)objectForKey:(<span class="keyword">id</span>)key &#123;</span><br><span class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁：保证线程安全</span></span><br><span class="line">    pthread_mutex_lock(&amp;_lock);</span><br><span class="line">    _YYLinkedMapNode *node = <span class="built_in">CFDictionaryGetValue</span>(_lru-&gt;_dic, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(key));</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">        <span class="comment">// 更新 _time</span></span><br><span class="line">        node-&gt;_time = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 🔔❗️❗️❗️ 🔔❗️❗️❗️</span></span><br><span class="line">        <span class="comment">// 将节点移动到头部</span></span><br><span class="line">        [_lru bringNodeToHead:node];</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数据返回</span></span><br><span class="line">    <span class="keyword">return</span> node ? node-&gt;_value : <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="bringNodeToHead"><a href="#bringNodeToHead" class="headerlink" title="bringNodeToHead"></a>bringNodeToHead</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// YYMemoryCache.m</span></span><br><span class="line">- (<span class="keyword">void</span>)bringNodeToHead:(_YYLinkedMapNode *)node &#123;</span><br><span class="line">    <span class="keyword">if</span> (_head == node) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (_tail == node) &#123;</span><br><span class="line">        _tail = node-&gt;_prev;</span><br><span class="line">        _tail-&gt;_next = <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;_next-&gt;_prev = node-&gt;_prev;</span><br><span class="line">        node-&gt;_prev-&gt;_next = node-&gt;_next;</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;_next = _head;</span><br><span class="line">    node-&gt;_prev = <span class="literal">nil</span>;</span><br><span class="line">    _head-&gt;_prev = node;</span><br><span class="line">    _head = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="YYMemoryCache读取操作时间复杂度O-1"><a href="#YYMemoryCache读取操作时间复杂度O-1" class="headerlink" title="YYMemoryCache读取操作时间复杂度O(1)"></a>YYMemoryCache读取操作时间复杂度O(1)</h1><p>在官方的文档中，我们得知 <code>YYMemoryCache</code> 读取操作相关api的时间复杂度为 <code>O(1)</code>,那么是如何做到的呢？</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">_YYLinkedMap</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">@package</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 🔔❗️❗️❗️ 🔔❗️❗️❗️</span></span><br><span class="line">    <span class="built_in">CFMutableDictionaryRef</span> _dic; <span class="comment">// do not set object directly</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> _totalCost;</span><br><span class="line">    <span class="built_in">NSUInteger</span> _totalCount;</span><br><span class="line">    _YYLinkedMapNode *_head; <span class="comment">// MRU, do not change it directly</span></span><br><span class="line">    _YYLinkedMapNode *_tail; <span class="comment">// LRU, do not change it directly</span></span><br><span class="line">    <span class="built_in">BOOL</span> _releaseOnMainThread;</span><br><span class="line">    <span class="built_in">BOOL</span> _releaseAsynchronously;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是这个 <code>CFMutableDictionaryRef</code> 类型的 <code>_dic</code>;<br><code>CFMutableDictionaryRef</code> 本质是一个 <code>哈希结构</code>;</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)objectForKey:(<span class="keyword">id</span>)key &#123;</span><br><span class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    pthread_mutex_lock(&amp;_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 🔔❗️❗️❗️ 🔔❗️❗️❗️</span></span><br><span class="line">    <span class="comment">// 直接从 CFMutableDictionaryRef 中取出数据</span></span><br><span class="line">    _YYLinkedMapNode *node = <span class="built_in">CFDictionaryGetValue</span>(_lru-&gt;_dic, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(key));</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">        node-&gt;_time = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">        [_lru bringNodeToHead:node];</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;_lock);</span><br><span class="line">    <span class="keyword">return</span> node ? node-&gt;_value : <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="post-copyright"><p class="copyright-item"> <span>Author:</span> <a href="http://yotrolz.com">YotrolZ</a></p><p class="copyright-item"> <span>Link:</span> <a href="http://yotrolz.com/posts/ac25c853/">http://yotrolz.com/posts/ac25c853/</a></p><p class="copyright-item"> <span>License:</span> <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a></p></div><footer class="post-footer"><nav class="post-nav"><a class="prev" href="/posts/cad520f4/"><i class="iconfont icon-left"></i> <span class="prev-text nav-default">iOS @synchronized(object)底层原理</span> <span class="prev-text nav-mobile">Prev</span></a> <a class="next" href="/posts/5c5f8fb2/"><span class="next-text nav-default">YYCache源码学习-磁盘缓存分析</span> <span class="prev-text nav-mobile">Next</span><i class="iconfont icon-right"></i></a></nav></footer></article></div><div class="comments" id="comments"></div></div></main><footer id="footer" class="footer"><div class="social-links"></div><div class="copyright"> <span class="power-by">Powered by <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a></span> <span class="division">|</span> <span class="theme-info">Theme - <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/ahonn/hexo-theme-even">Even</a></span> <span class="copyright-year">&copy;2015 - 2022<span class="heart"><i class="iconfont icon-heart"></i></span> <span class="author">YotrolZ</span></span></div></footer><div class="back-to-top" id="back-to-top"><i class="iconfont icon-up"></i></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/yotrolz/yotrolz.github.io@gh/lib/jquery/jquery.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/yotrolz/yotrolz.github.io@gh/lib/slideout/slideout.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/yotrolz/yotrolz.github.io@gh/lib/fancybox/jquery.fancybox.pack.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/yotrolz/yotrolz.github.io@gh/js/src/even.js?v=2.11.0"></script></body></html>