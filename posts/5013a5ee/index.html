<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="theme-color" content="#f8f5ec"><meta name="msapplication-navbutton-color" content="#f8f5ec"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec"><meta name="description" content="所谓原子操作(atomic)，就是不可分割的操作，在其操作所属期间，不会因为`线程调度`而被打断。肯定会想到关于iOS开发中各种锁的线程同步方案。 本文旨在讲解在引用计数中涉及到的原子操作，别有一番风味，请慢慢享用~~"><link rel="alternate" href="/atom.xml" title="YotrolZ" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.11.0"><link rel="canonical" href="http://yotrolz.com/posts/5013a5ee/"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/yotrolz/yotrolz.github.io@gh/lib/fancybox/jquery.fancybox.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/yotrolz/yotrolz.github.io@gh/css/style.css?v=2.11.0"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-138610487-3"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-138610487-3")</script><script id="baidu_push">!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script src="//cdn.jsdelivr.net/npm/leancloud-storage@4.10.0/dist/av-min.js"></script><script id="leancloud">AV.init({appId:"mqfPQEKBtui9puAJUkYFY7Jn-MdYXbMMI",appKey:"A6R0T4bEvcBsTU8pB7NhJ6Wl"})</script><script>window.config={leancloud:{show_visits:!1,app_id:"mqfPQEKBtui9puAJUkYFY7Jn-MdYXbMMI",app_key:"A6R0T4bEvcBsTU8pB7NhJ6Wl"},toc:!0,fancybox:!0,pjax:"",latex:!1}</script><title>iOS 引用计数中惊艳的原子操作(一) - YotrolZ</title><meta name="generator" content="Hexo 5.4.1"></head><body><div id="mobile-navbar" class="mobile-navbar"><div class="mobile-header-logo"> <a href="/." class="logo">YotrolZ</a></div><div class="mobile-navbar-icon"><span></span><span></span><span></span></div></div><nav id="mobile-menu" class="mobile-menu slideout-menu"><ul class="mobile-menu-list"><a href="/"><li class="mobile-menu-item">Home</li></a><a href="/archives/"><li class="mobile-menu-item">Archives</li></a><a href="/tags/"><li class="mobile-menu-item">Tags</li></a><a href="/categories/"><li class="mobile-menu-item">Categories</li></a></ul></nav><div class="container" id="mobile-panel"><header id="header" class="header"><div class="logo-wrapper"> <a href="/." class="logo">YotrolZ</a></div><nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item"> <a class="menu-item-link" href="/">Home</a></li><li class="menu-item"> <a class="menu-item-link" href="/archives/">Archives</a></li><li class="menu-item"> <a class="menu-item-link" href="/tags/">Tags</a></li><li class="menu-item"> <a class="menu-item-link" href="/categories/">Categories</a></li></ul></nav></header><main id="main" class="main"><div class="content-wrapper"><div id="content" class="content"><article class="post"><header class="post-header"><h1 class="post-title">iOS 引用计数中惊艳的原子操作(一)</h1><div class="post-meta"> <span class="post-time">2021-01-19</span> <span class="post-visits" style="display:none" data-url="/posts/5013a5ee/" data-title="iOS 引用计数中惊艳的原子操作(一)">Visits 0</span></div></header><div class="post-toc" id="post-toc"><h2 class="post-toc-title">Contents</h2><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0"><span class="toc-text">简述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E5%A4%84%E7%90%86%E5%99%A8%E5%8D%95%E6%A0%B8%E7%B3%BB%E7%BB%9F"><span class="toc-text">单处理器单核系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E6%88%96%E5%A4%9A%E6%A0%B8%E7%B3%BB%E7%BB%9F"><span class="toc-text">多处理器或多核系统</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#iOS-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%85%B3%E9%94%AE%E6%BA%90%E7%A0%81"><span class="toc-text">iOS 引用计数关键源码</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E4%B8%AD%E5%8F%91%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">源码中发现的问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E5%8C%96%E6%BA%90%E7%A0%81"><span class="toc-text">简化源码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#slowpath-%E5%92%8C-fastpath"><span class="toc-text">slowpath 和 fastpath</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#LoadExclusive-%E5%92%8C-StoreExclusive"><span class="toc-text">LoadExclusive 和 StoreExclusive</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#arm64"><span class="toc-text">arm64</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4-ldxr-%E5%92%8C-stxr"><span class="toc-text">汇编指令: ldxr 和 stxr</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ldxr-%E6%8C%87%E4%BB%A4"><span class="toc-text">ldxr 指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stxr-%E6%8C%87%E4%BB%A4"><span class="toc-text">stxr 指令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#x86-64-i386"><span class="toc-text">x86_64 || i386</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sync-bool-compare-and-swap-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0"><span class="toc-text">__sync_bool_compare_and_swap 内置函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#do-while-%E5%BE%AA%E7%8E%AF%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">do while 循环的作用</span></a></li></ol></div></div><div class="post-content"><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>所谓<code>原子操作(atomic)</code>，就是不可分割的操作，在其操作所属期间，不会因为<code>线程调度</code>而被打断。</p><h2 id="单处理器单核系统"><a href="#单处理器单核系统" class="headerlink" title="单处理器单核系统"></a>单处理器单核系统</h2><p>在单处理器系统上，如果操作是在单个CPU指令中实现的，则该操作始终是原子的。</p><h2 id="多处理器或多核系统"><a href="#多处理器或多核系统" class="headerlink" title="多处理器或多核系统"></a>多处理器或多核系统</h2><p>在多处理器系统上，确保原子性存在一点困难。要达到原子操作，就需要进行相应的处理。比如我们经常听到的<code>自旋锁</code>、<code>互斥锁</code>、<code>信号量</code>等线程同步方案。</p><blockquote><p>本文旨在讲解在 <code>iOS</code> 中<code>引用计数</code>中涉及到的原子操作，别有一番风味，请慢慢享用~</p></blockquote><h1 id="iOS-引用计数关键源码"><a href="#iOS-引用计数关键源码" class="headerlink" title="iOS 引用计数关键源码"></a>iOS 引用计数关键源码</h1><p>在<code>objc_object</code>源码中，关于内存应用计数相关的方法，通过一个<code>宏判断</code>实现了两套逻辑，代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> SUPPORT_NONPOINTER_ISA</span></span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yotrolz/image@master/blog/objc-object.h.jpg" alt="objc_object 相关方法列表"></p><p>我们这里只分析<code>SUPPORT_NONPOINTER_ISA</code>下的<code>objc_object::rootRetain</code>，具体源码如下：</p><ul><li>调用<code>retain</code>，其实会来到这里，不做过多解释；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ALWAYS_INLINE id </span></span><br><span class="line"><span class="function"><span class="title">objc_object::rootRetain</span><span class="params">(<span class="type">bool</span> tryRetain, <span class="type">bool</span> handleOverflow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isTaggedPointer</span>()) <span class="keyword">return</span> (id)<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> sideTableLocked = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> transcribeToSideTable = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">isa_t</span> oldisa;</span><br><span class="line">    <span class="type">isa_t</span> newisa;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ❓❓❓问题点1：这里怎么会有一个 do while 循环❓❓❓</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        transcribeToSideTable = <span class="literal">false</span>;</span><br><span class="line">        oldisa = <span class="built_in">LoadExclusive</span>(&amp;isa.bits);</span><br><span class="line">        newisa = oldisa;</span><br><span class="line">        <span class="comment">// ① 非nonpointer</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">slowpath</span>(!newisa.nonpointer)) &#123;</span><br><span class="line">            <span class="built_in">ClearExclusive</span>(&amp;isa.bits);</span><br><span class="line">            <span class="keyword">if</span> (!tryRetain &amp;&amp; sideTableLocked) <span class="built_in">sidetable_unlock</span>();</span><br><span class="line">            <span class="keyword">if</span> (tryRetain) <span class="keyword">return</span> <span class="built_in">sidetable_tryRetain</span>() ? (id)<span class="keyword">this</span> : nil;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">sidetable_retain</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ② nonpointer (重点分析)</span></span><br><span class="line">        <span class="comment">// don&#x27;t check newisa.fast_rr; we already called any RR overrides</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">slowpath</span>(tryRetain &amp;&amp; newisa.deallocating)) &#123;</span><br><span class="line">            <span class="built_in">ClearExclusive</span>(&amp;isa.bits);</span><br><span class="line">            <span class="keyword">if</span> (!tryRetain &amp;&amp; sideTableLocked) <span class="built_in">sidetable_unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> nil;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">uintptr_t</span> carry;</span><br><span class="line">        <span class="comment">// 进行 引用计数加一 操作 </span></span><br><span class="line">        <span class="comment">// ❓❓❓问题点2：这里加一操作为什么没有上述lock、unlock之类的加锁操作❓❓❓</span></span><br><span class="line">        newisa.bits = <span class="built_in">addc</span>(newisa.bits, RC_ONE, <span class="number">0</span>, &amp;carry);  <span class="comment">// extra_rc++</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">slowpath</span>(carry)) &#123;</span><br><span class="line">            <span class="comment">// 这里其实是 newisa.extra_rc++ 溢出的逻辑(不是本文分析重点)</span></span><br><span class="line">            <span class="comment">// newisa.extra_rc++ overflowed</span></span><br><span class="line">            <span class="keyword">if</span> (!handleOverflow) &#123;</span><br><span class="line">                <span class="built_in">ClearExclusive</span>(&amp;isa.bits);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">rootRetain_overflow</span>(tryRetain);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Leave half of the retain counts inline and </span></span><br><span class="line">            <span class="comment">// prepare to copy the other half to the side table.</span></span><br><span class="line">            <span class="keyword">if</span> (!tryRetain &amp;&amp; !sideTableLocked) <span class="built_in">sidetable_lock</span>();</span><br><span class="line">            sideTableLocked = <span class="literal">true</span>;</span><br><span class="line">            transcribeToSideTable = <span class="literal">true</span>;</span><br><span class="line">            newisa.extra_rc = RC_HALF;</span><br><span class="line">            newisa.has_sidetable_rc = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">slowpath</span>(!<span class="built_in">StoreExclusive</span>(&amp;isa.bits, oldisa.bits, newisa.bits)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(transcribeToSideTable)) &#123;</span><br><span class="line">        <span class="comment">// Copy the other half of the retain counts to the side table.</span></span><br><span class="line">        <span class="built_in">sidetable_addExtraRC_nolock</span>(RC_HALF);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(!tryRetain &amp;&amp; sideTableLocked)) <span class="built_in">sidetable_unlock</span>();</span><br><span class="line">    <span class="keyword">return</span> (id)<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="源码中发现的问题"><a href="#源码中发现的问题" class="headerlink" title="源码中发现的问题"></a>源码中发现的问题</h1><ul><li><p>问题①：为什么要加一个 <code>do while</code> 循环？</p></li><li><p>问题②：<code>newisa.bits = addc(newisa.bits, RC_ONE, 0, &amp;carry);</code>为什么不需要<code>加锁</code>等相关操作，那么该操作如何保证<code>线程同步</code>的呢？</p></li><li><p><em>一个猜想</em>： 莫非这个<code>addc</code>加一操作是通过 <code>do while</code> 来实现<code>原子操作</code>的？</p></li></ul><h1 id="简化源码"><a href="#简化源码" class="headerlink" title="简化源码"></a>简化源码</h1><ul><li>精简掉 关于 <code>SideTable</code> 存储引用计数的部分及 <code>isa.extra_rc++</code> 溢出后的处理</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ALWAYS_INLINE id </span></span><br><span class="line"><span class="function"><span class="title">objc_object::rootRetain</span><span class="params">(<span class="type">bool</span> tryRetain, <span class="type">bool</span> handleOverflow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">isa_t</span> oldisa;</span><br><span class="line">    <span class="type">isa_t</span> newisa;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ❓❓❓问题点1：这里怎么会有一个 do while 循环❓❓❓</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line"></span><br><span class="line">        oldisa = <span class="built_in">LoadExclusive</span>(&amp;isa.bits);</span><br><span class="line">        newisa = oldisa;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ❓❓❓问题点2：这里加一操作为什么没有上述lock、unlock之类的加锁操作❓❓❓</span></span><br><span class="line">        <span class="comment">// 进行 引用计数加一 操作 </span></span><br><span class="line">        newisa.bits = <span class="built_in">addc</span>(newisa.bits, RC_ONE, <span class="number">0</span>, &amp;carry);  <span class="comment">// extra_rc++</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">slowpath</span>(!<span class="built_in">StoreExclusive</span>(&amp;isa.bits, oldisa.bits, newisa.bits)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (id)<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="slowpath-和-fastpath"><a href="#slowpath-和-fastpath" class="headerlink" title="slowpath 和 fastpath"></a>slowpath 和 fastpath</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> fastpath(x) (__builtin_expect(bool(x), 1))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> slowpath(x) (__builtin_expect(bool(x), 0))</span></span><br></pre></td></tr></table></figure><ul><li>这个指令是<code>gcc</code>引入的，我们可以用<code>__builtin_expect</code>来向<code>编译器</code>提供分支<code>预测</code>信息;</li><li><code>__builtin_expect(long exp, long c)</code>代表的意思是：预测 <code>exp === c</code>;</li></ul><p>由此我们可以知晓，上述源码中：</p><ul><li><code>!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)</code>结果为<code>0</code> 的可能性更大；</li><li>也就是说这个<code>do while</code> <strong>执行循环的可能性会比较小</strong>(不然是何其的消耗性能，这只是从代码层面上面的分析，这里提出，只是为了避免被这个<code>do while</code>纸老虎给哄住。我们继续);</li></ul><p>我们从 <code>do while</code> 中的条件：<code>while (slowpath(!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)));</code> 入手分析</p><blockquote><p>重点来了~</p></blockquote><h1 id="LoadExclusive-和-StoreExclusive"><a href="#LoadExclusive-和-StoreExclusive" class="headerlink" title="LoadExclusive 和 StoreExclusive"></a>LoadExclusive 和 StoreExclusive</h1><ul><li><code>Exclusive</code>: 独有的；排外的；专一的;</li></ul><p>在源码中<code>StoreExclusive</code>对于不同的<code>处理器架构</code>有三种不同的实现：</p><ul><li><code>__arm64__</code></li><li><code>__arm__</code></li><li><code>__x86_64__ || __i386__</code></li></ul><p><img src="https://cdn.jsdelivr.net/gh/yotrolz/image@master/blog/objc_object-rootRetain.jpg" alt="LoadExclusive &amp; StoreExclusive"></p><blockquote><p>我们先从 <strong>arm64</strong> 开始分析</p></blockquote><h2 id="arm64"><a href="#arm64" class="headerlink" title="arm64"></a><strong>arm64</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pointer-size register prefix for inline asm</span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> __LP64__</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> p <span class="string">&quot;x&quot;</span>  <span class="comment">// true arm64</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> p <span class="string">&quot;w&quot;</span>  <span class="comment">// arm64_32</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> ALWAYS_INLINE <span class="type">uintptr_t</span> </span></span><br><span class="line"><span class="function"><span class="title">LoadExclusive</span><span class="params">(<span class="type">uintptr_t</span> *src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uintptr_t</span> result;</span><br><span class="line">    <span class="built_in">asm</span>(<span class="string">&quot;ldxr %&quot;</span> p <span class="string">&quot;0, [%x1]&quot;</span> </span><br><span class="line">        : <span class="string">&quot;=r&quot;</span> (result) </span><br><span class="line">        : <span class="string">&quot;r&quot;</span> (src), <span class="string">&quot;m&quot;</span> (*src));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> ALWAYS_INLINE <span class="type">bool</span> </span></span><br><span class="line"><span class="function"><span class="title">StoreExclusive</span><span class="params">(<span class="type">uintptr_t</span> *dst, <span class="type">uintptr_t</span> oldvalue __unused, <span class="type">uintptr_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> result;</span><br><span class="line">    <span class="built_in">asm</span>(<span class="string">&quot;stxr %w0, %&quot;</span> p <span class="string">&quot;2, [%x3]&quot;</span> </span><br><span class="line">        : <span class="string">&quot;=&amp;r&quot;</span> (result), <span class="string">&quot;=m&quot;</span> (*dst)</span><br><span class="line">        : <span class="string">&quot;r&quot;</span> (value), <span class="string">&quot;r&quot;</span> (dst));</span><br><span class="line">    <span class="keyword">return</span> !result;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     ldaxr    w1, [x0] add</span></span><br><span class="line"><span class="comment">     w1,      w1, #0x1 stlxr</span></span><br><span class="line"><span class="comment">     w2,      w1, [x0]</span></span><br><span class="line"><span class="comment">     cbnz     w2, top</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>如果不清楚<code>__LP64__</code>的可以翻看我之前的一片文章；</li><li>内部实现居然是<code>汇编</code>，我们将重要的指令提出进行分析：<code>ldxr</code> 和 <code>stxr</code> 指令;</li><li><code>ldxr</code> 为 <code>LoadExclusive</code> 的重要内部实现</li><li><code>stxr</code> 为 <code>StoreExclusive</code> 的重要内部实现</li></ul><h3 id="汇编指令-ldxr-和-stxr"><a href="#汇编指令-ldxr-和-stxr" class="headerlink" title="汇编指令: ldxr 和  stxr"></a>汇编指令: ldxr 和 stxr</h3><ul><li>这是<code>ARM</code>中的<code>原子操作指令</code>，是不是发现了新大陆。</li></ul><h4 id="ldxr-指令"><a href="#ldxr-指令" class="headerlink" title="ldxr 指令"></a>ldxr 指令</h4><ul><li><p>Load exclusive register</p></li><li><p><a target="_blank" rel="noopener" href="https://developer.arm.com/documentation/dui0801/i/A64-Data-Transfer-Instructions/LDXR?lang=en">ldxr - ARM 官方文档</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LDXR  Wt, [Xn|SP&#123;,#<span class="number">0</span>&#125;]    ; <span class="number">32</span>-bit general registers</span><br><span class="line">LDXR  Xt, [Xn|SP&#123;,#<span class="number">0</span>&#125;]    ; <span class="number">64</span>-bit general registers</span><br></pre></td></tr></table></figure></li><li><p><code>Wt</code>：32位的通用寄存器名称，范围：<code>0 ~ 31</code></p></li><li><p><code>Xt</code>：64位的通用寄存器名称，范围：<code>0 ~ 31</code></p></li><li><p><code>Xn|SP</code>：64位的通用基址寄存器或堆栈指针，范围：<code>0 ~ 31</code></p></li><li><p><em>说明：<code>32位/64位</code> 代表寄存器的 <code>容量</code>，<code>范围</code> 可以理解为寄存器的 <code>编号</code></em></p></li></ul><h4 id="stxr-指令"><a href="#stxr-指令" class="headerlink" title="stxr 指令"></a>stxr 指令</h4><ul><li><p>Store exclusive register, returning status.</p></li><li><p><a target="_blank" rel="noopener" href="https://developer.arm.com/documentation/dui0801/i/A64-Data-Transfer-Instructions/STXR?lang=en">stxr - ARM 官方文档</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">STXR  Ws, Wt, [Xn|SP&#123;,#<span class="number">0</span>&#125;]    ; <span class="number">32</span>-bit general registers</span><br><span class="line">STXR  Ws, Xt, [Xn|SP&#123;,#<span class="number">0</span>&#125;]    ; <span class="number">64</span>-bit general registers</span><br></pre></td></tr></table></figure></li><li><p><code>Wt</code>：32位的通用寄存器名称，范围：<code>0 ~ 31</code></p></li><li><p><code>Xt</code>：64位的通用寄存器名称，范围：<code>0 ~ 31</code></p></li><li><p><code>Ws</code>：32位的通用寄存器名称，存储 <code>exclusive</code> 的状态</p></li><li><p><code>Xn|SP</code>：64位的通用基址寄存器或堆栈指针，范围：<code>0 ~ 31</code></p></li><li><p><em>说明：<code>32位/64位</code> 代表寄存器的 <code>容量</code>，<code>范围</code> 可以理解为寄存器的 <code>编号</code></em></p></li></ul><blockquote><p>关于<code>Exclusive accesses</code>更多内容可以参考ARM开发者文档中对<a target="_blank" rel="noopener" href="https://developer.arm.com/documentation/dht0008/a/arm-synchronization-primitives/exclusive-accesses?lang=en">Exclusive accesses</a> 的介绍</p></blockquote><h2 id="x86-64-i386"><a href="#x86-64-i386" class="headerlink" title="x86_64  ||  i386"></a><strong>x86_64</strong> || <strong>i386</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> ALWAYS_INLINE <span class="type">uintptr_t</span> </span></span><br><span class="line"><span class="function"><span class="title">LoadExclusive</span><span class="params">(<span class="type">uintptr_t</span> *src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *src;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> ALWAYS_INLINE <span class="type">bool</span> </span></span><br><span class="line"><span class="function"><span class="title">StoreExclusive</span><span class="params">(<span class="type">uintptr_t</span> *dst, <span class="type">uintptr_t</span> oldvalue, <span class="type">uintptr_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __sync_bool_compare_and_swap((<span class="type">void</span> **)dst, (<span class="type">void</span> *)oldvalue, (<span class="type">void</span> *)value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sync-bool-compare-and-swap-内置函数"><a href="#sync-bool-compare-and-swap-内置函数" class="headerlink" title="__sync_bool_compare_and_swap 内置函数"></a><code>__sync_bool_compare_and_swap</code> 内置函数</h3><ul><li><code>Compare And Swap</code>，简称<code>CAS</code>;</li><li>简单来说就是，在<code>写入</code>新值之前， 先根据<code>内存地址</code>读出<code>此刻内存真实值</code>，然后与<code>此刻操作期望值</code>进行比较，当且仅当<code>此刻内存真实值</code>与<code>此刻操作期望值</code>一致时，才将<code>此刻操作期望值</code>写入，并返回<code>true</code>。</li><li>可能有点绕，联想着多线程的<code>数据竞争</code>慢慢体会；<ul><li>比如：此刻期望将数据修改为10，但是由于多线程的缘故，此刻内存中的真实值并不一定为10，如果不为10，就不执行写入操作；</li></ul></li></ul><h1 id="do-while-循环的作用"><a href="#do-while-循环的作用" class="headerlink" title="do while 循环的作用"></a>do while 循环的作用</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简化代码</span></span><br><span class="line">objc_object::<span class="built_in">rootRetain</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">isa_t</span> oldisa; <span class="comment">// 用于存储此刻内存中的真实值</span></span><br><span class="line">    <span class="type">isa_t</span> newisa; <span class="comment">// 用于存储此刻操作期的期望值</span></span><br><span class="line">    </span><br><span class="line">    oldisa = <span class="built_in">LoadExclusive</span>(&amp;isa.bits); <span class="comment">// 从内存中读取此刻真实值</span></span><br><span class="line">    newisa = oldisa;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// extra_rc++ 溢出标记</span></span><br><span class="line">        <span class="type">uintptr_t</span> carry;</span><br><span class="line">        <span class="comment">// extra_rc++</span></span><br><span class="line">        newisa.bits = <span class="built_in">addc</span>(newisa.bits, RC_ONE, <span class="number">0</span>, &amp;carry);</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">slowpath</span>(!<span class="built_in">StoreExclusive</span>(&amp;isa.bits, oldisa.bits, newisa.bits)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就很直观了~</p><ul><li>注意<code>while</code> 条件中的 取反操作 <code>!</code>;</li><li>如果写入不成功，那就一直执行循环，直到写入成功；</li><li>当然，由我们之前对<code>slowpath</code>和<code>LoadExclusive / StoreExclusive</code>的分析，可知：预测分析执行循环的概率比较低，只有在线程数据竞争的时候发生；正常情况下，是不会进入循环的(执行一次<code>do</code>)；</li><li>有点<code>自旋锁</code>的味道，慢慢体会；</li></ul></div><div class="post-copyright"><p class="copyright-item"> <span>Author:</span> <a href="http://yotrolz.com">YotrolZ</a></p><p class="copyright-item"> <span>Link:</span> <a href="http://yotrolz.com/posts/5013a5ee/">http://yotrolz.com/posts/5013a5ee/</a></p><p class="copyright-item"> <span>License:</span> <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a></p></div><footer class="post-footer"><nav class="post-nav"><a class="prev" href="/posts/3a49a1ae/"><i class="iconfont icon-left"></i> <span class="prev-text nav-default">iOS 引用计数中惊艳的原子操作(二)</span> <span class="prev-text nav-mobile">Prev</span></a> <a class="next" href="/posts/8367b1/"><span class="next-text nav-default">objc_msgSend及方法缓存</span> <span class="prev-text nav-mobile">Next</span><i class="iconfont icon-right"></i></a></nav></footer></article></div><div class="comments" id="comments"></div></div></main><footer id="footer" class="footer"><div class="social-links"></div><div class="copyright"> <span class="power-by">Powered by <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a></span> <span class="division">|</span> <span class="theme-info">Theme - <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/ahonn/hexo-theme-even">Even</a></span> <span class="copyright-year">&copy;2015 - 2022<span class="heart"><i class="iconfont icon-heart"></i></span> <span class="author">YotrolZ</span></span></div></footer><div class="back-to-top" id="back-to-top"><i class="iconfont icon-up"></i></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/yotrolz/yotrolz.github.io@gh/lib/jquery/jquery.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/yotrolz/yotrolz.github.io@gh/lib/slideout/slideout.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/yotrolz/yotrolz.github.io@gh/lib/fancybox/jquery.fancybox.pack.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/yotrolz/yotrolz.github.io@gh/js/src/even.js?v=2.11.0"></script></body></html>